<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transaction Splitter</title>
    <style>
        /* Styling to match Period Tracker V2_13.html */
        *, *::before, *::after {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
              Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif; /* Period App Font */
            margin: 0; 
            padding: 0; 
            background-color: #ffffff; /* Period App Body Background */
            color: #333;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .container {
            /* CHANGES FOR WIDER DESKTOP USE: */
            max-width: none; 
            width: 98%; 
            min-width: 600px; 
            margin: 20px auto;
            /* END CHANGES */

            background-color: #fff;
            padding: 20px;
            border-radius: 8px; 
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); 
            border: 1px solid #cce5ff; 
        }
        h1 {
            /* Style to match the look of the Period App's h2 and header */
            color: #2473BC; 
            border-bottom: 2px solid #76AFE5; 
            padding-bottom: 4px;
            margin-bottom: 1.5rem;
            font-size: 50px; 
            text-align: center;
            font-weight: 700;
        }
        /* --- New #total-container styles for prominence --- */
        #total-container {
            background-color: #eaf3fb; 
            border: 1px solid #cce5ff; 
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 6px; 
            
            display: grid;
            grid-template-columns: 1fr 1fr;
            text-align: center;
            font-weight: 600;
        }
        .total-box {
            display: flex;
            flex-direction: column;
            padding: 10px;
        }
        .total-box.my-share {
            color: #2473BC; /* My Share is primary blue */
            border-right: 1px solid #cce5ff; /* Separator line */
        }
        .total-box.full-total {
            color: #333;
        }
        .total-amount {
            font-size: 2.5em; /* Bigger font for amount */
            font-weight: 700;
            line-height: 1.1;
        }
        .total-label {
            font-size: 0.9em;
            margin-top: 5px;
            color: #666; /* Gray out the label slightly */
        }
        .total-box.my-share .total-label {
            color: #2473BC;
        }
        /* ----------------------------------------------------------------- */
        
        /* --- Import/Export Controls Layout (50/50 Split) --- */
        .controls-wrapper {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px; 
            margin-bottom: 20px;
        }

        /* Removed blue box frame for import/export containers */
        #import-controls-container {
            display: flex; 
            flex-direction: column;
            gap: 10px; 
            padding: 0; 
            border: none; 
            background-color: transparent; 
            border-radius: 6px; 
        }
        
        /* Removed blue box frame for import/export containers */
        #export-frame {
            display: flex;
            flex-direction: column;
            justify-content: center; 
            padding: 0; 
            border: none;
            background-color: transparent;
            border-radius: 6px; 
        }
        
        .import-action-button {
            padding: 12px 20px;
            font-size: 1.1rem;
            background-color: #2473BC;
            color: white;
            width: 100%;
        }

        /* UPDATED STYLING FOR EXPORT BUTTON (Light Blue) */
        #export-frame button {
            padding: 12px 20px;
            font-size: 1.1rem;
            background-color: #CDE6F8; /* Light Blue Background */
            color: #2473BC; /* Primary Blue Text */
            border: 2px solid #76AFE5; /* Border to match the frame */
            width: 100%; 
            height: 100%; 
            margin: 0;
            display: block;
            font-weight: 700;
        }

        /* Hide the actual file input */
        #csv-file-input {
            display: none; 
        }

        /* --- Tab Styling --- */
        .tabs {
            display: flex;
            border-bottom: 2px solid #76AFE5;
            margin-bottom: 20px;
        }
        .tab-button {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            background-color: #f8fbfe;
            color: #2473BC;
            font-weight: 600;
            transition: all 0.2s;
        }
        .tab-button.active {
            border-color: #76AFE5;
            border-bottom: 2px solid white; 
            background-color: white;
            color: #2473BC;
            margin-bottom: -2px; 
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        
        /* --- NEW STYLES FOR TRANSACTION HEADER CONTROLS (Filters + Add Button) --- */
        .transactions-header-controls {
            display: flex; 
            justify-content: space-between; /* Push button to the right */
            align-items: center; /* Vertically align items */
            margin-bottom: 20px;
            gap: 20px; /* Space between filter section and button */
        }

        /* Style the filter section for existing elements */
        #filter-presets {
            display: flex;
            align-items: center;
            gap: 10px; /* Space between filter elements */
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }
        
        /* Style the new button to match the size of a select/input */
        #add-transaction-btn {
            padding: 10px 20px; /* Similar to select padding */
            font-size: 0.95rem; /* Similar to select font size */
            background-color: #2473BC; /* Primary blue color */
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            /* FIX: Ensure width is determined by content only and it doesn't grow */
            width: auto; 
            flex-grow: 0; 
        }
        
        #category-controls {
            display: flex; 
            gap: 10px;
        }
        
        #add-category-btn {
            padding: 10px 15px; 
            font-size: 0.95rem; 
            background-color: #CDE6F8; 
            color: #2473BC; 
            border: 1px solid #76AFE5; 
            border-radius: 6px; 
            font-weight: 600;
            width: auto; 
            flex-grow: 0; 
        }
        /* --- END NEW STYLES --- */


        /* --- Table Styling and Sorting --- */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: left;
            vertical-align: middle; 
        }
        th {
            background-color: #79AFDE; 
            color: white;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        /* Clickable headers */
        th.sortable {
            cursor: pointer;
            position: relative;
        }
        th.sortable::after {
            content: '';
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            border: 4px solid transparent;
            opacity: 0.5;
        }
        th.sortable.asc::after {
            content: '▲';
            opacity: 1;
            font-size: 0.7em;
            right: 5px;
        }
        th.sortable.desc::after {
            content: '▼';
            opacity: 1;
            font-size: 0.7em;
            right: 5px;
        }

        tr:nth-child(even) {
            background-color: #f8fbfe; 
        }

        /* Gray-out style for N/A rows */
        .na-applied td {
            color: #989898; 
            font-style: italic;
        }
        
        .notes-input {
            width: 100%;
            padding: 4px 6px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 0.85rem;
        }

        /* --- Buttons and Modals --- */
        .action-buttons-grid, .import-actions-grid {
            display: grid;
            /* MODIFIED: Change to 2 columns for a 2x2 layout */
            grid-template-columns: 1fr 1fr; 
            gap: 5px;
            width: 100%;
        }
        
        /* NEW: Full width for manual entry actions (1 button only now) */
        .action-buttons-grid.single-button {
             grid-template-columns: 1fr;
        }

        .import-actions-grid {
            grid-template-columns: 1fr 1fr; 
        }
        .cc-buttons-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        .cc-buttons-grid button {
            width: 100%;
            font-size: 1rem;
            padding: 12px 5px;
            background-color: #79AFDE;
            color: white;
            border: none;
        }
        
        button {
            padding: 8px 5px; 
            margin: 0; 
            width: 100%; 
            cursor: pointer;
            border: none;
            border-radius: 6px; 
            font-weight: 600; 
            transition: all 0.2s;
            font-size: 0.9rem; 
            box-sizing: border-box; 
        }

        .btn-full, .btn-split-half, .btn-split-custom, .btn-change-cc { 
            background-color: #79AFDE; 
            color: white; 
        } 
        .btn-na, .btn-delete { 
            background-color: #989898; 
            color: white;
        }
        .btn-delete { background-color: #e66666; }

        /* Default state: all buttons are outlines */
        .action-button {
            background-color: transparent !important;
            border: 2px solid #79AFDE; 
            color: #2473BC !important; 
            font-weight: 600;
            padding: 6px 5px; 
        }
        .btn-na.action-button { 
            border-color: #989898; 
            color: #989898 !important;
        }

        /* Action Applied State (Turns into a solid-filled button) */
        .btn-full.applied, .btn-split-half.applied, .btn-split-custom.applied { 
            background-color: #79AFDE !important; 
            color: white !important; 
            border: none;
        }
        
        /* OVERRIDE: Set Full button to the main blue color (#2473BC) when applied */
        .btn-full.applied {
            background-color: #2473BC !important; 
            color: white !important; 
            border: none !important;
        }

        .btn-na.applied { 
            background-color: #989898 !important; 
            color: white !important; 
            border: none;
        }


        .negative { color: black; } 
        .positive { color: green; } 

        select, input[type="number"], input[type="text"], input[type="date"] {
            padding: 8px 10px;
            border-radius: 6px;
            border: 1px solid #cce5ff; 
            margin-right: 10px;
            box-sizing: border-box;
            font-size: 0.95rem;
            min-width: 150px; 
        }

        /* Target all select elements in the table for a small padding */
        .category-select {
            width: 100%;
            padding: 6px 8px; 
            font-size: 0.85rem;
        }
        
        /* --- Modal Styling Updates --- */
        .modal {
            display: none; 
            position: fixed; 
            z-index: 100; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.4); 
        }
        .modal-content {
            background-color: #fefefe;
            margin: 10% auto; 
            padding: 25px;
            border: 1px solid #76AFE5; 
            width: 90%; 
            max-width: 500px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(36, 115, 188, 0.2); 
            position: relative; /* REQUIRED for close-btn positioning */
        }
        
        /* Custom Split Modal Row Spacing */
        .modal-details div, 
        .modal-field {
            margin-bottom: 10px; 
        }
        
        /* Styling for the manual transaction form fields */
        #manualTransactionModal .modal-field {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #manualTransactionModal .modal-field label {
            font-weight: 600;
            font-size: 0.9em;
            color: #333;
        }
        #manualTransactionModal .modal-field input, 
        #manualTransactionModal .modal-field select {
            min-width: 100%;
            box-sizing: border-box;
            margin: 0;
        }
        
        /* Make the modal button row three columns when editing (Save, Delete, Cancel) */
        #manualTransactionModal .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        #manualTransactionModal .modal-buttons button {
            flex: 1;
        }
        
        /* Ensure split buttons in modal don't stretch vertically */
        #manual-split-buttons button {
            height: auto; 
            padding: 6px 5px;
        }


        /* Close button positioning */
        .close-btn {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            position: absolute; 
            top: 10px; 
            right: 15px; 
            cursor: pointer;
            line-height: 1; 
            padding: 0;
            margin: 0;
            background: none; 
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Transaction Splitter</h1>

    <div class="controls-wrapper">
        
        <div id="import-controls-container">
            <button class="import-action-button" onclick="triggerFileUpload('new')">Import Transactions</button>
            <button class="import-action-button" onclick="triggerFileUpload('old')">Import Old Data</button>
        </div>

        <div id="export-frame">
            <button onclick="exportToCSV()">Export All Data to CSV</button>
        </div>
        
        <input type="file" id="csv-file-input" accept=".csv" multiple>
    </div>

    <div class="tabs">
        <button class="tab-button active" onclick="openTab('transactions-tab', this)">Transactions</button>
        <button class="tab-button" onclick="openTab('imports-tab', this)">File Imports</button>
        <button class="tab-button" onclick="openTab('category-breakdown-tab', this)">Category Breakdown</button>
    </div>

    <div id="transactions-tab" class="tab-content active">
        <div id="total-container">
            <div class="total-box my-share">
                <span id="full-my-total" class="total-amount">$0.00</span>
                <span class="total-label">My Share</span>
            </div>
            <div class="total-box full-total">
                <span id="full-original-total" class="total-amount">$0.00</span>
                <span class="total-label">Full Total Amount</span>
            </div>
        </div>
        <div id="filter-controls" class="transactions-header-controls">
            <div id="filter-presets">
                <label for="date-range-preset">View Range:</label>
                <select id="date-range-preset" onchange="applyDateFilter()">
                    <option value="current_month">This Month</option>
                    <option value="last_month">Last Month</option>
                    <option value="all_time">All Time</option>
                    <option value="custom">Custom Range</option>
                </select>

                <div id="custom-date-range" style="display: none;">
                    <label for="start-date">Start Date:</label>
                    <input type="date" id="start-date" onchange="applyDateFilter()">
                    
                    <label for="end-date">End Date:</label>
                    <input type="date" id="end-date" onchange="applyDateFilter()">
                </div>
            </div>
            <div id="category-controls">
                <button id="add-transaction-btn" onclick="openManualTransactionModal()">Add Manual Transaction</button>
                <button id="add-category-btn" onclick="openNewCategoryModal()">Add Category</button>
            </div>
        </div>
        <div id="transactions-list">
            <table>
                <thead>
                    <tr>
                        <th style="width: 8%;" class="sortable" data-sort-key="dateObj" onclick="sortTransactions('dateObj')">Date</th>
                        <th style="width: 10%;">Credit Card</th>
                        <th style="width: 20%;">Description</th>
                        <th style="width: 10%;">Category</th>
                        <th style="width: 8%;">Original Amount</th>
                        <th style="width: 8%;">My Total</th>
                        <th style="width: 16%;">Actions</th>
                        <th style="width: 20%;">Notes</th>
                    </tr>
                </thead>
                <tbody id="transactions-body">
                    </tbody>
            </table>
        </div>
    </div>

    <div id="imports-tab" class="tab-content">
        <h2>Imported Files History</h2>
        <div id="imports-list">
            <table>
                <thead>
                    <tr>
                        <th style="width: 40%;">File Name</th>
                        <th style="width: 25%;">Credit Card</th>
                        <th style="width: 15%;">Transactions</th>
                        <th style="width: 20%;">Actions</th>
                    </tr>
                </thead>
                <tbody id="imports-body">
                </tbody>
            </table>
        </div>
    </div>

    <div id="category-breakdown-tab" class="tab-content">
        <h2>Category Breakdown</h2>
        <div id="breakdown-filter-controls">
            <label for="breakdown-date-range-preset">View Range:</label>
            <select id="breakdown-date-range-preset" onchange="applyBreakdownFilter()">
                <option value="current_month">This Month</option>
                <option value="last_month">Last Month</option>
                <option value="all_time" selected>All Time</option>
            </select>
        </div>
        <div id="category-breakdown-list">
            <table>
                <thead>
                    <tr>
                        <th style="width: 20%;">Category</th>
                        <th style="width: 15%;">Transaction Count</th>
                        <th style="width: 15%;" class="sortable" data-sort-key="percentage" onclick="sortBreakdown('percentage')">Percentages</th>
                        <th style="width: 20%;">Total Original Amount</th>
                        <th style="width: 15%;">Total My Share</th>
                        <th style="width: 15%;">Actions</th> </tr>
                </thead>
                <tbody id="breakdown-body">
                    <tr><td colspan="6" style="text-align: center; color: #666; padding: 20px;">Load transactions to see breakdown.</td></tr>
                </tbody>
                <tfoot id="breakdown-footer"></tfoot>
            </table>
        </div>
    </div>
</div>

<div id="creditCardSelectModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('creditCardSelectModal')">&times;</span>
        <h2 id="cc-modal-title">Select Credit Card for Imported File</h2>
        <p>Please choose which credit card these transactions are from:</p>
        <div id="cc-buttons-container" class="cc-buttons-grid">
            </div>
    </div>
</div>

<div id="changeCCModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('changeCCModal')">&times;</span>
        <h2 id="reassign-cc-title">Reassign Credit Card</h2>
        <p>Select a new card for: <strong id="reassign-file-name"></strong></p>
        <div id="reassign-buttons-container" class="cc-buttons-grid">
            </div>
    </div>
</div>

<div id="customSplitModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('customSplitModal')">&times;</span>
        <h2>Split Transaction</h2>

        <div class="modal-details">
            <div><strong>Date:</strong> <span id="modal-date"></span></div>
            <div><strong>Description:</b> <span id="modal-description"></span></div>
            <div><strong>Category:</b> <span id="modal-category"></span></div>
            <div><strong>Original Amount:</b> <span id="modal-original-amount" style="font-weight: bold;">$0.00</span></div>
        </div>

        <div class="modal-field">
            <label for="split-ways">Total Number of Ways to Split:</label>
            <input type="number" id="split-ways" value="2" min="1" onchange="validateSplitWays()">
        </div>

        <div class="modal-field">
            <label for="split-type">Split Type:</label>
            <select id="split-type" onchange="toggleCustomPortionField()">
                <option value="even">Even Split</option>
                <option value="custom">Custom Split</option>
            </select>
        </div>

        <div class="modal-field" id="custom-portion-field" style="display: none;">
            <label for="my-custom-portion">Your Custom Portion (My Total):</label>
            <input type="number" id="my-custom-portion" placeholder="e.g., 5.00" step="0.01" min="0">
        </div>

        <div class="modal-buttons">
            <button onclick="applyCustomSplit()" class="btn-split-half">Apply Split</button>
            <button onclick="closeModal('customSplitModal')" class="btn-na">Cancel</button>
        </div>
    </div>
</div>

<div id="manualTransactionModal" class="modal" data-context="add">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('manualTransactionModal')">&times;</span>
        <h2>Add Manual Transaction</h2>
        
        <div class="modal-field">
            <label for="manual-date">Date <span style="color: red;">*</span></label>
            <input type="date" id="manual-date" required>
        </div>

        <div class="modal-field">
            <label for="manual-cc">Credit Card</label>
            <select id="manual-cc"></select>
        </div>
        
        <div class="modal-field">
            <label for="manual-desc">Description</label>
            <input type="text" id="manual-desc">
        </div>
        
        <div class="modal-field">
            <label for="manual-category">Category</label>
            <select id="manual-category" class="category-select"></select>
        </div>

        <div class="modal-field">
            <label for="manual-original-amount">Original Amount ($) <span style="color: red;">*</span></label>
            <input type="number" id="manual-original-amount" step="0.01" placeholder="e.g., -55.75" required oninput="handleManualAmountChange()">
            <small style="color: #666; margin-top: -5px;">Put minus if a transaction is a charge (e.g., -55.75).</small>
        </div>
        
        <div class="modal-field">
            <label>Split Status</label>
            <div id="manual-split-buttons" class="action-buttons-grid">
                <button class="btn-split-half action-button" data-action="half" onclick="handleManualSplitAction('half')">Half</button>
                <button class="btn-full action-button" data-action="full" onclick="handleManualSplitAction('full')">Full</button>
                <button class="btn-split-custom action-button" data-action="custom" onclick="openManualCustomSplitModal()">Custom Split</button>
                <button class="btn-na action-button" data-action="na" onclick="handleManualSplitAction('na')">N/A</button>
            </div>
        </div>
        
        <div class="modal-field">
            <label for="manual-my-total">My Total ($)</label>
            <input type="number" id="manual-my-total" step="0.01" placeholder="e.g., -27.88" oninput="handleManualMyTotalInput()">
        </div>
        
        <div class="modal-field">
            <label for="manual-notes">Notes</label>
            <input type="text" id="manual-notes">
        </div>

        <div class="modal-buttons" id="manual-modal-action-buttons">
            <button onclick="saveManualTransaction()" class="btn-full" id="manual-save-btn">Save Transaction</button>
            <button onclick="closeModal('manualTransactionModal')" class="btn-na">Cancel</button>
        </div>
    </div>
</div>

<div id="newCategoryModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('newCategoryModal')">&times;</span>
        <h2>Add New Category</h2>
        
        <div class="modal-field">
            <label for="new-category-name-input" style="font-weight: 600;">Category Name:</label>
            <input type="text" id="new-category-name-input" placeholder="e.g., Groceries" required>
        </div>

        <div class="modal-buttons" style="margin-top: 20px;">
            <button onclick="addNewCategory()" class="btn-full" style="background-color: #2473BC;">Add Category</button>
            <button onclick="closeModal('newCategoryModal')" class="btn-na">Cancel</button>
        </div>
    </div>
</div>
<div id="manageCategoryModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('manageCategoryModal')">&times;</span>
        <h2>Manage Category: <strong id="current-category-name-display"></strong></h2>
        
        <p style="font-weight: bold; margin-top: 10px;">Rename Category</p>
        <div class="modal-field">
            <label for="new-category-name">New Name:</label>
            <input type="text" id="new-category-name" placeholder="Enter new category name">
        </div>
        
        <div class="modal-buttons" style="margin-bottom: 25px;">
            <button onclick="performRenameCategory()" class="btn-full" id="rename-category-btn" style="background-color: #2473BC;">Rename Category</button>
        </div>
        
        <hr style="border-top: 1px solid #cce5ff; margin: 15px 0;">
        
        <p style="font-weight: bold; color: #e66666; margin-bottom: 10px;">Danger Zone: Delete Category</p>
        <div class="modal-buttons">
            <button onclick="deleteCategory(currentManagingCategory)" class="btn-delete">Delete & Re-categorize to 'Uncategorized'</button>
        </div>
        <small style="color: #989898; margin-top: 5px; display: block;">This action cannot be undone.</small>

        <div class="modal-buttons" style="margin-top: 20px;">
            <button onclick="closeModal('manageCategoryModal')" class="btn-na">Close</button>
        </div>
    </div>
</div>
<script>
    // Global Constants
    const CREDIT_CARD_OPTIONS = [
        'Unlimited 3993', 
        'Sapphire 8906', 
        'Target', 
        'My CC',
        'Manual' // Added 'Manual' as a default CC option for manual entries
    ];
    // Special value to signal that card selection was skipped and to look in CSV
    const SKIP_CC_SELECTION = 'OLD_DATA_AUTO_ASSIGN'; 
    
    // Special ID for manual entries, which are now hidden from the imports list
    const MANUAL_ENTRY_ID = 0; 
    
    // Global variables
    let transactions = []; 
    let displayedTransactions = []; 
    let uniqueCategories = new Set();
    let fullOriginalTotal = 0;
    let fullMyTotal = 0;
    let currentTransactionIndex = null; 
    let editingTransactionIndex = null; 
    let currentManagingCategory = null; 
    
    // Sorting State
    let transactionSort = { key: 'dateObj', direction: 'asc' }; 
    let breakdownSort = { key: 'percentage', direction: 'desc' };
    
    // Data structures for file management
    let filesToProcess = []; 
    let currentProcessingFile = null; 
    let importedFilesHistory = []; 
    let reassigningFileIndex = null; 
    let currentImportType = 'new'; // 'new' or 'old'
    let currentBreakdownData = []; // To hold the category data for sorting

    // Event listener for the actual file input (now hidden)
    document.getElementById('csv-file-input').addEventListener('change', initializeFileUpload);
    document.getElementById('date-range-preset').addEventListener('change', applyDateFilter);
    document.getElementById('breakdown-date-range-preset').addEventListener('change', applyBreakdownFilter);

    // Initial setup of CC buttons in the two modals AND the CC dropdown in manual entry modal
    (function setupCCButtons() {
        const container = document.getElementById('cc-buttons-container');
        const reassignContainer = document.getElementById('reassign-buttons-container');
        const manualCCSelect = document.getElementById('manual-cc');
        
        CREDIT_CARD_OPTIONS.forEach(cardName => {
            // Initial Import Modal Buttons
            const btn1 = document.createElement('button');
            btn1.textContent = cardName;
            btn1.onclick = () => handleCreditCardSelection(cardName);
            container.appendChild(btn1);

            // Reassign CC Modal Buttons
            const btn2 = document.createElement('button');
            btn2.textContent = cardName;
            btn2.onclick = () => reassignCreditCard(reassigningFileIndex, cardName);
            reassignContainer.appendChild(btn2);
            
            // Manual Entry CC Dropdown Options
            const option = document.createElement('option');
            option.value = cardName;
            option.textContent = cardName;
            manualCCSelect.appendChild(option);
        });
        // Default the manual entry dropdown to the last option ('Manual') or first option
        manualCCSelect.value = 'Manual'; 
    })();
    
    // --- Utility Functions ---
    
    // Helper function to parse date strings and prevent timezone issues
    function parseDateInput(dateString) {
        // Appends T12:00:00 to treat the date as noon local time, mitigating timezone shifts
        if (!dateString) return null;
        // Check for common formats and handle them, but mostly rely on T12:00:00
        const datePart = dateString.split('T')[0];
        
        // This attempts to parse the date as a date string plus a time offset 
        // to prevent it from being interpreted as UTC midnight (which shifts the day).
        let date = new Date(datePart + 'T12:00:00');
        
        // Fallback for non-standard formats that the above logic might fail, but still need the local fix.
        // This is important for re-importing old, formatted dates.
        if (isNaN(date.getTime())) {
            date = new Date(dateString + 'T12:00:00');
        }

        // Final fallback on the raw string for very ambiguous formats
        if (isNaN(date.getTime())) {
            date = new Date(dateString);
        }
        
        return isNaN(date.getTime()) ? null : date;
    }

    function updateTotalsDisplay() {
        document.getElementById('full-original-total').textContent = formatCurrency(fullOriginalTotal);
        document.getElementById('full-my-total').textContent = formatCurrency(fullMyTotal);
    }

    function formatCurrency(amount) {
        return new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: 'USD'
        }).format(amount);
    }
    
    window.onclick = function(event) {
        const customSplitModal = document.getElementById('customSplitModal');
        const ccSelectModal = document.getElementById('creditCardSelectModal');
        const changeCCModal = document.getElementById('changeCCModal');
        const manualTxnModal = document.getElementById('manualTransactionModal');
        const manageCatModal = document.getElementById('manageCategoryModal');
        const newCatModal = document.getElementById('newCategoryModal'); // NEW MODAL
        
        if (event.target == customSplitModal) {
            closeModal('customSplitModal');
        } else if (event.target == ccSelectModal) {
            closeModal('creditCardSelectModal');
        } else if (event.target == changeCCModal) {
             closeModal('changeCCModal');
        } else if (event.target == manualTxnModal) {
             closeModal('manualTransactionModal');
        } else if (event.target == manageCatModal) {
             closeModal('manageCategoryModal');
        } else if (event.target == newCatModal) { // NEW CHECK
             closeModal('newCategoryModal');
        }
    }
    
    // --- End Utility Functions ---

    // --- Trigger File Input ---
    function triggerFileUpload(type) {
        currentImportType = type;
        document.getElementById('csv-file-input').click();
    }

    // --- Tab Switching ---
    function openTab(tabId, element) {
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
        document.querySelectorAll('.tab-button').forEach(button => button.classList.remove('active'));

        document.getElementById(tabId).classList.add('active');
        element.classList.add('active');
        
        if (tabId === 'imports-tab') {
            renderImportsHistory();
        } else if (tabId === 'category-breakdown-tab') {
            applyBreakdownFilter(); // Trigger calculation on tab switch
        }
    }

    // --- File Handling Functions ---
    function initializeFileUpload(event) {
        const fileList = event.target.files;
        if (fileList.length > 0) {
            filesToProcess.push(...Array.from(fileList));
            event.target.value = null; 
            processNextFileInQueue(); 
        }
    }

    function processNextFileInQueue() {
        if (filesToProcess.length > 0) {
            currentProcessingFile = filesToProcess.shift(); 
            
            if (currentImportType === 'old') {
                // SKIP CC MODAL for old data. Pass the skip constant.
                handleCreditCardSelection(SKIP_CC_SELECTION);
            } else {
                // Regular process: show modal for new data
                document.getElementById('cc-modal-title').textContent = `Select Card for: ${currentProcessingFile.name}`;
                openModal('creditCardSelectModal');
            }
        } else {
            processTransactions();
        }
    }
    
    function handleCreditCardSelection(selectedCard) {
        // Hide modal if it was open (including if the selection was a real click)
        document.getElementById('creditCardSelectModal').style.display = 'none';
        
        const file = currentProcessingFile;
        if (!file) {
            processNextFileInQueue();
            return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
            const csvData = e.target.result;
            // Pass the import type to parseCSV for logic branching
            const newTransactions = parseCSV(csvData, selectedCard, file.name, currentImportType); 
            
            transactions.push(...newTransactions); 
            
            if (newTransactions.length > 0) {
                // Use a unique ID based on timestamp for files
                const fileId = Date.now() + Math.random(); 
                
                importedFilesHistory.push({
                    id: fileId, 
                    fileName: file.name,
                    creditCard: selectedCard === SKIP_CC_SELECTION ? 'Multiple/Archived' : selectedCard, // Set placeholder for history
                    transactionCount: newTransactions.length
                });
            }

            currentProcessingFile = null; 
            processNextFileInQueue();
        };
        reader.readAsText(file);
    }

    function renderImportsHistory() {
        const tbody = document.getElementById('imports-body');
        tbody.innerHTML = '';

        // NEW: Filter out the MANUAL_ENTRY_ID
        const filteredHistory = importedFilesHistory.filter(f => f.id !== MANUAL_ENTRY_ID);

        if (filteredHistory.length === 0) {
            tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #666; padding: 20px;">No files imported yet.</td></tr>';
            return;
        }

        filteredHistory.forEach((fileEntry, index) => {
            const row = tbody.insertRow();
            row.dataset.id = fileEntry.id;
            
            row.insertCell().textContent = fileEntry.fileName;
            row.insertCell().textContent = fileEntry.creditCard;
            row.insertCell().textContent = fileEntry.transactionCount;

            const actionCell = row.insertCell();
            actionCell.classList.add('actions');
            
            actionCell.innerHTML = `
                <div class="import-actions-grid">
                    <button class="btn-change-cc" onclick="openReassignModal(${fileEntry.id})">Change CC</button>
                    <button class="btn-delete" onclick="deleteImportedFile(${fileEntry.id})">Delete</button>
                </div>
            `;
            
        });
    }

    function openReassignModal(fileId) {
        if (fileId === MANUAL_ENTRY_ID) return; // Cannot reassign the manual entry group

        const fileEntry = importedFilesHistory.find(f => f.id === fileId);
        if (!fileEntry) return;

        reassigningFileIndex = fileId;
        document.getElementById('reassign-file-name').textContent = fileEntry.fileName;

        const oldContainer = document.getElementById('reassign-buttons-container');
        const newContainer = oldContainer.cloneNode(true);
        oldContainer.parentNode.replaceChild(newContainer, oldContainer);
        newContainer.id = 'reassign-buttons-container'; 

        const buttons = newContainer.querySelectorAll('button');
        buttons.forEach(button => {
            const cardName = button.textContent;
            button.onclick = () => reassignCreditCard(fileId, cardName);
        });

        openModal('changeCCModal');
    }

    function reassignCreditCard(fileId, newCard) {
        const fileEntry = importedFilesHistory.find(f => f.id === fileId);
        if (!fileEntry) return;

        transactions.forEach(t => {
            if (t.fileName === fileEntry.fileName) { 
                t.creditCard = newCard;
            }
        });

        fileEntry.creditCard = newCard;
        
        closeModal('changeCCModal');
        
        renderImportsHistory();
        applyDateFilter(); 
    }

    function deleteImportedFile(fileId) {
        if (fileId === MANUAL_ENTRY_ID) {
            // Manual entries are now deleted via the in-line button, but keep this check for safety.
            alert('Manual entries are managed via the Edit/Delete button in the transaction list.');
            return;
        } else {
            if (!confirm('Are you sure you want to delete this file and all its associated transactions? This action cannot be undone.')) return;

            const fileEntry = importedFilesHistory.find(f => f.id === fileId);
            if (!fileEntry) return;

            const fileNameToDelete = fileEntry.fileName;

            // Remove transactions associated with the file
            transactions = transactions.filter(t => t.fileName !== fileNameToDelete);
            
            // Remove the file entry from history
            importedFilesHistory = importedFilesHistory.filter(f => f.id !== fileId);
        }

        // Recalculate unique categories after deletion
        uniqueCategories.clear();
        transactions.forEach(t => {
            if (t.category) uniqueCategories.add(t.category);
        });

        renderImportsHistory();
        applyDateFilter(); // Re-render transactions
        applyBreakdownFilter(); // Update breakdown
    }

    function parseCSV(csvData, creditCard, fileName, importType) {
        const lines = csvData.trim().split('\n');
        if (lines.length <= 1) {
            alert(`File "${fileName}" skipped: No data rows found.`);
            return [];
        }

        const EXCLUDED_CATEGORIES = ["credit card payments", "transfers"]; 

        const parseLine = (line) => {
            const result = [];
            let inQuotes = false;
            let currentField = '';
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(currentField.trim());
                    currentField = '';
                } else {
                    currentField += char;
                }
            }
            result.push(currentField.trim());
            return result.map(v => v.replace(/^"|"$/g, ''));
        };

        const header = parseLine(lines[0]);
        const dataLines = lines.slice(1);
        const parsedData = [];

        const headerMap = header.reduce((acc, col, index) => {
            const cleanCol = col.trim().toLowerCase();
            acc[cleanCol] = index;
            // Also map common variations of credit card column
            if (cleanCol.includes('credit card') || cleanCol.includes('cc') || cleanCol.includes('card name') || cleanCol.includes('account')) {
                acc['credit card from csv'] = index;
            }
            return acc;
        }, {});

        const dateIndex = headerMap['date'];
        const descIndex = headerMap['description'];
        const categoryIndex = headerMap['category'];
        
        // Check for 'amount' first, then fallback to 'original amount' for compatibility
        const amountIndex = headerMap['amount'] !== undefined ? headerMap['amount'] : headerMap['original amount'];
        
        const ccCsvIndex = headerMap['credit card from csv']; 
        
        // INDICES FOR RE-IMPORTING OLD/EXPORTED DATA
        const myTotalIndex = headerMap['my total'];
        const statusIndex = headerMap['split status']; 
        const notesIndex = headerMap['notes']; 

        if (dateIndex === undefined || amountIndex === undefined) {
            alert(`File "${fileName}" skipped: CSV must contain 'Date' and one of 'Amount' or 'Original Amount' columns (case-insensitive).`);
            return [];
        }
        
        dataLines.forEach(line => {
            const values = parseLine(line);
            if (values.length > 0) {
                const amountStr = values[amountIndex] || '0';
                const originalAmount = parseFloat(amountStr.replace(/[^0-9.-]/g, '')) || 0;
                
                if (originalAmount === 0 && amountStr.replace(/[^0-9.-]/g, '').trim() !== '0') return;

                const category = (values[categoryIndex] || 'Uncategorized').trim(); // Trim category
                
                // Exclude "credit card payments" and "transfers"
                if (EXCLUDED_CATEGORIES.includes(category.toLowerCase())) {
                    return; // Skip this transaction
                }
                
                uniqueCategories.add(category);
                
                let finalCreditCard = creditCard;
                let myTotal = 0;
                let status = '';
                let notes = '';

                // LOGIC FOR "OLD DATA" IMPORT
                if (importType === 'old') {
                    // Try to auto-assign credit card from CSV
                    if (ccCsvIndex !== undefined) {
                        const csvCardValue = values[ccCsvIndex].trim();
                        finalCreditCard = csvCardValue || 'Archived Data'; 
                    } else {
                        // Fallback if no CC column found, use placeholder
                        finalCreditCard = 'Archived Data'; 
                    }
                    // Restore My Total, Status, and Notes if columns exist in the exported file
                    if (myTotalIndex !== undefined) {
                        const myTotalStr = values[myTotalIndex] || '0';
                        myTotal = parseFloat(myTotalStr.replace(/[^0-9.-]/g, '')) || 0;
                    }
                    if (statusIndex !== undefined) {
                        status = values[statusIndex].trim();
                    }
                    if (notesIndex !== undefined) {
                        notes = values[notesIndex].trim();
                    }
                } else if (finalCreditCard === SKIP_CC_SELECTION) {
                    // Fallback for 'old' data import that didn't have a CC column (left for safety, but above logic handles it)
                    finalCreditCard = 'Archived Data';
                }

                // Use parseDateInput to create dateObj
                const dateString = values[dateIndex];
                const dateObj = parseDateInput(dateString);

                parsedData.push({
                    date: dateString,
                    dateObj: dateObj,
                    description: values[descIndex] || '',
                    category: category,
                    creditCard: finalCreditCard,
                    originalAmount: originalAmount,
                    myTotal: myTotal, // Set to parsed value or default 0
                    status: status, // Set to parsed value or default ''
                    fileName: fileName,
                    notes: notes // Set to parsed value or default ''
                });
            }
        });

        if (parsedData.length === 0 && dataLines.length > 0) {
            console.warn(`Warning: Found data rows in "${fileName}" but parsed 0 transactions. Check CSV format.`);
        }
        return parsedData;
    }

    function formatDate(dateString) {
        const date = parseDateInput(dateString); // Use parseDateInput to get a valid date
        if (date === null) return dateString; // Return original string if unparsable
        const options = { year: 'numeric', month: 'short', day: 'numeric' };
        return date.toLocaleDateString('en-US', options);
    }

    function processTransactions() {
        // Initial sort: Date ASC
        transactions.sort((a, b) => {
            if (!a.dateObj) return 1;
            if (!b.dateObj) return -1;
            return a.dateObj.getTime() - b.dateObj.getTime();
        });
        transactions.forEach(t => {
            if (t.category) uniqueCategories.add(t.category);
        });
        reRenderCategoryDropdowns();
        applyDateFilter();
    }
    
    // --- Transaction Sorting and Filtering ---
    function sortTransactions(key) {
        if (transactionSort.key === key) {
            transactionSort.direction = transactionSort.direction === 'asc' ? 'desc' : 'asc';
        } else {
            transactionSort.key = key;
            transactionSort.direction = key === 'dateObj' ? 'asc' : 'desc'; // Default sort
        }

        displayedTransactions.sort((a, b) => {
            const aVal = a[key];
            const bVal = b[key];
            let comparison = 0;

            if (key === 'dateObj') {
                const aTime = aVal ? aVal.getTime() : 0;
                const bTime = bVal ? bVal.getTime() : 0;
                comparison = aTime - bTime;
            } else if (typeof aVal === 'number' && typeof bVal === 'number') {
                comparison = aVal - bVal;
            } else {
                comparison = String(aVal).localeCompare(String(bVal));
            }
            
            return transactionSort.direction === 'asc' ? comparison : -comparison;
        });

        updateSortIndicators('transactions-list', transactionSort);
        renderTransactions();
    }

    function updateSortIndicators(listId, sortState) {
        document.querySelectorAll(`#${listId} th.sortable`).forEach(th => {
            th.classList.remove('asc', 'desc');
            if (th.dataset.sortKey === sortState.key) {
                th.classList.add(sortState.direction);
            }
        });
    }

    function applyDateFilter() {
        const preset = document.getElementById('date-range-preset').value;
        const customRangeDiv = document.getElementById('custom-date-range');
        let startDate = null;
        let endDate = null;

        if (preset === 'custom') {
            customRangeDiv.style.display = 'flex'; // Use flex now that it's a div containing labels/inputs
            startDate = document.getElementById('start-date').value ? parseDateInput(document.getElementById('start-date').value) : null;
            endDate = document.getElementById('end-date').value ? parseDateInput(document.getElementById('end-date').value) : null;
            if (endDate) endDate.setHours(23, 59, 59, 999);
        } else {
            customRangeDiv.style.display = 'none';
            const now = new Date();
            let year = now.getFullYear();
            let month = now.getMonth();

            if (preset === 'current_month') {
                startDate = new Date(year, month, 1);
                endDate = new Date(year, month + 1, 0);
                endDate.setHours(23, 59, 59, 999);
            } else if (preset === 'last_month') {
                startDate = new Date(year, month - 1, 1);
                endDate = new Date(year, month, 0);
                endDate.setHours(23, 59, 59, 999);
            }
        }

        displayedTransactions = transactions.filter(t => {
            const date = t.dateObj;
            // Critical check: only proceed if date is a valid object
            if (!date) return false;

            const meetsStart = !startDate || date >= startDate;
            const meetsEnd = !endDate || date <= endDate;

            return meetsStart && meetsEnd;
        });

        // Reapply current sort after filtering
        sortTransactions(transactionSort.key); 
        // Note: renderTransactions is called inside sortTransactions now
        calculateTotals();
    }

    function calculateTotals() {
        // FILTER: Exclude transactions with category "My Payments" from totals calculation
        const filteredTxns = displayedTransactions.filter(t => t.category !== 'My Payments');
        
        fullOriginalTotal = filteredTxns.reduce((acc, t) => acc + t.originalAmount, 0);
        fullMyTotal = filteredTxns.reduce((acc, t) => acc + t.myTotal, 0);
        
        updateTotalsDisplay();
    }
    
    // --- Category Management Functions ---

    function openManageCategoryModal(categoryName) {
        if (['N/A', 'Uncategorized'].includes(categoryName)) return;

        currentManagingCategory = categoryName;
        document.getElementById('current-category-name-display').textContent = categoryName;
        document.getElementById('new-category-name').value = categoryName; // Pre-fill the input
        openModal('manageCategoryModal');
    }
    
    function openNewCategoryModal() {
        document.getElementById('new-category-name-input').value = '';
        openModal('newCategoryModal');
    }

    function addNewCategory() {
        const newName = document.getElementById('new-category-name-input').value.trim();

        if (!newName) {
            alert("Please enter a valid category name.");
            return;
        }
        
        if (uniqueCategories.has(newName)) {
            alert(`A category named "${newName}" already exists.`);
            return;
        }

        uniqueCategories.add(newName);
        
        closeModal('newCategoryModal');
        
        // Re-render all dropdowns (manual modal) and transaction list
        reRenderCategoryDropdowns(); 
        applyDateFilter(); // Re-render the main transaction list

        alert(`Category "${newName}" successfully added.`);
    }

    function performRenameCategory() {
        const oldName = currentManagingCategory;
        const newName = document.getElementById('new-category-name').value.trim();

        if (!newName || newName === oldName) {
            alert("Please enter a valid and different name for the category.");
            return;
        }
        
        if (uniqueCategories.has(newName)) {
            alert(`A category named "${newName}" already exists. Please choose another name.`);
            return;
        }
        
        if (!confirm(`Are you sure you want to rename "${oldName}" to "${newName}"?`)) {
            return;
        }

        // 1. Update all transactions
        transactions.forEach(t => {
            if (t.category === oldName) {
                t.category = newName;
            }
        });

        // 2. Update the uniqueCategories Set
        uniqueCategories.delete(oldName);
        uniqueCategories.add(newName);

        // 3. Close modal and re-render
        closeModal('manageCategoryModal');
        
        // Re-render everything that depends on categories
        reRenderCategoryDropdowns();
        applyDateFilter(); // Re-render transactions tab (will call renderTransactions)
        applyBreakdownFilter(); // Re-render breakdown tab (will call renderBreakdown)

        alert(`Category "${oldName}" successfully renamed to "${newName}".`);
    }

    function deleteCategory(categoryName) {
        if (['N/A', 'Uncategorized'].includes(categoryName)) return;
        
        if (!confirm(`Are you sure you want to DELETE the category "${categoryName}"? All ${categoryName} transactions will be moved to "Uncategorized". THIS CANNOT BE UNDONE.`)) {
            return;
        }
        
        // 1. Update all transactions
        transactions.forEach(t => {
            if (t.category === categoryName) {
                t.category = 'Uncategorized';
            }
        });

        // 2. Remove from the uniqueCategories Set
        uniqueCategories.delete(categoryName);

        // 3. Close modal (if open) and re-render
        closeModal('manageCategoryModal');
        
        // Re-render everything that depends on categories
        reRenderCategoryDropdowns();
        applyDateFilter(); // Re-render transactions tab
        applyBreakdownFilter(); // Re-render breakdown tab
        
        alert(`Category "${categoryName}" successfully deleted and transactions moved to "Uncategorized".`);
    }

    // This function populates select elements with class .category-select 
    // It is primarily used for the Manual Transaction Modal
    function reRenderCategoryDropdowns() {
        const selects = document.querySelectorAll('.category-select');
        selects.forEach(select => {
            // Store current value to re-select if possible
            const currentValue = select.value;
            select.innerHTML = renderCategorySelectOptions(currentValue);
            
            // Restore previous value if it still exists
            if (currentValue && select.querySelector(`option[value="${currentValue}"]`)) {
                 select.value = currentValue;
            } else {
                 select.value = 'Uncategorized'; // Fallback if category was deleted/renamed
            }
        });
    }
    
    // NEW HELPER FUNCTION to generate options HTML for a select element
    function renderCategorySelectOptions(currentCategory) {
        let optionsHtml = '';
        // Sort unique categories alphabetically, case-insensitive
        const sortedCategories = Array.from(uniqueCategories)
            .sort((a, b) => a.localeCompare(b));
            
        // Ensure 'Uncategorized' is at the top/default
        if (!uniqueCategories.has('Uncategorized')) {
            sortedCategories.unshift('Uncategorized');
        }

        sortedCategories.forEach(category => {
            const selected = category === currentCategory ? 'selected' : '';
            optionsHtml += `<option value="${category}" ${selected}>${category}</option>`;
        });
        
        return optionsHtml;
    }
    
    // NEW FUNCTION to handle category change from the main table dropdown
    function updateTransactionCategory(index, newCategory) {
        if (index >= 0 && index < transactions.length) {
            transactions[index].category = newCategory;
            
            // Recalculate totals and breakdown
            calculateTotals(); 
            applyBreakdownFilter(); 
        }
    }
    // --- End Category Management Functions ---
    
    function calculateCategoryBreakdown(filteredTransactions) {
        if (filteredTransactions.length === 0) {
            currentBreakdownData = [];
            renderBreakdown();
            return;
        }

        const categoryData = {};
        let totalTransactions = filteredTransactions.length;
        let grandOriginalTotal = 0;
        let grandMyTotal = 0;

        filteredTransactions.forEach(t => {
            const cat = t.category || 'N/A';
            if (!categoryData[cat]) {
                categoryData[cat] = { count: 0, originalTotal: 0, myTotal: 0 };
            }
            categoryData[cat].count++;
            
            // --- MODIFIED LOGIC: EXCLUDE "My Payments" from totals and grand totals ---
            if (cat !== 'My Payments') {
                categoryData[cat].originalTotal += t.originalAmount;
                categoryData[cat].myTotal += t.myTotal;
                grandOriginalTotal += t.originalAmount;
                grandMyTotal += t.myTotal;
            }
            // --- END MODIFIED LOGIC ---
        });

        // Prepare data for rendering/sorting
        const totalOriginalAmount = grandOriginalTotal;
        currentBreakdownData = Object.keys(categoryData).map(cat => {
            const data = categoryData[cat];
            // --- MODIFIED CALCULATION FOR PERCENTAGES BASED ON TOTAL ORIGINAL AMOUNT ---
            // Percentage is calculated based on the category's originalTotal against the grandOriginalTotal (which excludes My Payments)
            const percentage = totalOriginalAmount === 0 ? 0 : (data.originalTotal / totalOriginalAmount) * 100;
            // --------------------------------------------------------------------------
            return {
                name: cat,
                count: data.count,
                originalTotal: data.originalTotal,
                myTotal: data.myTotal,
                percentage: percentage
            };
        });

        currentBreakdownData.grandOriginalTotal = grandOriginalTotal;
        currentBreakdownData.grandMyTotal = grandMyTotal;
        currentBreakdownData.totalTransactions = totalTransactions;

        // Apply current breakdown sort
        sortBreakdown(breakdownSort.key);
    }

    function sortBreakdown(key) {
        if (currentBreakdownData.length === 0) return;

        if (breakdownSort.key === key) {
            breakdownSort.direction = breakdownSort.direction === 'asc' ? 'desc' : 'asc';
        } else {
            breakdownSort.key = key;
            breakdownSort.direction = (key === 'percentage' || key === 'count' || key === 'originalTotal' || key === 'myTotal') ? 'desc' : 'asc';
        }

        currentBreakdownData.sort((a, b) => {
            const aVal = a[key];
            const bVal = b[key];
            let comparison = 0;

            if (typeof aVal === 'number' && typeof bVal === 'number') {
                comparison = aVal - bVal;
            } else {
                comparison = String(aVal).localeCompare(String(bVal));
            }
            
            return breakdownSort.direction === 'asc' ? comparison : -comparison;
        });

        updateSortIndicators('category-breakdown-list', breakdownSort);
        renderBreakdown();
    }

    function renderBreakdown() {
        const breakdownBody = document.getElementById('breakdown-body');
        const breakdownFooter = document.getElementById('breakdown-footer');
        breakdownBody.innerHTML = '';
        breakdownFooter.innerHTML = '';

        if (currentBreakdownData.length === 0) {
            breakdownBody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #666; padding: 20px;">Load transactions and apply filter to see breakdown.</td></tr>';
            return;
        }

        let grandOriginalTotal = currentBreakdownData.grandOriginalTotal;
        let grandMyTotal = currentBreakdownData.grandMyTotal;
        let totalTransactions = currentBreakdownData.totalTransactions;

        currentBreakdownData.forEach(data => {
            // Protected categories cannot be deleted or renamed
            const isProtected = ['N/A', 'Uncategorized'].includes(data.name);
            // My Payments is also protected for management, but has special display rules
            const isMyPayments = data.name === 'My Payments';

            const row = breakdownBody.insertRow();
            row.insertCell().textContent = data.name;
            row.insertCell().textContent = data.count;
            
            // Special display for My Payments: show no percentage
            if (isMyPayments) {
                 row.insertCell().textContent = 'N/A';
            } else {
                 row.insertCell().textContent = data.percentage.toFixed(2) + '%';
            }
            
            // Special display for My Payments: show $0.00
            if (isMyPayments) {
                row.insertCell().textContent = formatCurrency(0);
                row.insertCell().textContent = formatCurrency(0);
            } else {
                row.insertCell().textContent = formatCurrency(data.originalTotal);
                row.insertCell().textContent = formatCurrency(data.myTotal);
            }

            // Actions Cell
            const actionCell = row.insertCell();
            if (isProtected) {
                actionCell.textContent = 'Protected';
                actionCell.style.color = '#989898';
                actionCell.style.textAlign = 'center';
            } else {
                // Escape single quotes for use in JS function calls
                const safeCatName = data.name.replace(/'/g, "\\'"); 
                actionCell.innerHTML = `
                    <button onclick="openManageCategoryModal('${safeCatName}')" 
                            style="flex: 1; padding: 6px 5px; font-size: 0.85rem; background-color: #2473BC; color: white;">Manage</button>
                `;
            }
        });

        // Add footer (Total Row)
        const footerRow = breakdownFooter.insertRow();
        footerRow.style.fontWeight = 'bold';
        footerRow.style.borderTop = '2px solid #333';
        
        footerRow.insertCell().textContent = 'TOTAL (Excl. My Payments)'; // Updated Label
        footerRow.insertCell().textContent = totalTransactions;
        footerRow.insertCell().textContent = '100.00%'; // Always 100%
        footerRow.insertCell().textContent = formatCurrency(grandOriginalTotal);
        footerRow.insertCell().textContent = formatCurrency(grandMyTotal);
        footerRow.insertCell().textContent = ''; // Blank cell for Actions
    }
    
    // --- Manual Entry Functions ---
    function openManualTransactionModal(index = null) {
        const modal = document.getElementById('manualTransactionModal');
        const isEditing = index !== null;
        editingTransactionIndex = index;
        
        reRenderCategoryDropdowns(); 

        document.getElementById('manual-original-amount').disabled = false;
        document.getElementById('manual-my-total').disabled = false;
        
        // Get the Save/Delete/Cancel button container
        const actionButtonsContainer = document.getElementById('manual-modal-action-buttons');
        
        // Remove the previous Delete button if it exists
        const existingDeleteButton = document.getElementById('manual-delete-btn');
        if (existingDeleteButton) {
            existingDeleteButton.remove();
        }

        if (isEditing) {
            modal.querySelector('h2').textContent = 'Edit Transaction';
            modal.dataset.context = 'edit';
            const t = transactions[index];
            document.getElementById('manual-date').value = t.date;
            document.getElementById('manual-cc').value = t.creditCard;
            document.getElementById('manual-desc').value = t.description;
            document.getElementById('manual-category').value = t.category || '';
            document.getElementById('manual-original-amount').value = t.originalAmount;
            document.getElementById('manual-my-total').value = t.myTotal;
            document.getElementById('manual-notes').value = t.notes;

            // Update split buttons to reflect current status
            document.querySelectorAll('#manual-split-buttons button').forEach(btn => {
                btn.classList.remove('applied');
            });
            
            // --- UPDATED LOGIC TO FIX 'Split Half' STATUS ISSUE WHEN EDITING ---
            if (t.status === 'Half' || t.status === 'Split Half') {
                modal.querySelector('[data-action="half"]').classList.add('applied');
            } else if (t.status === 'Full') {
                modal.querySelector('[data-action="full"]').classList.add('applied');
            } else if (t.status === 'Custom Split') {
                modal.querySelector('[data-action="custom"]').classList.add('applied');
            } else if (t.status === 'N/A') {
                modal.querySelector('[data-action="na"]').classList.add('applied');
            }
            // --- END UPDATED LOGIC ---

            // Handle My Total display and locking for editing
            if (t.status === 'Full') {
                 document.getElementById('manual-my-total').value = t.originalAmount;
                 document.getElementById('manual-my-total').disabled = true;
            } else if (t.status === 'Half' || t.status === 'Split Half') {
                 document.getElementById('manual-my-total').value = (t.originalAmount / 2).toFixed(2);
                 document.getElementById('manual-my-total').disabled = true;
            } else if (t.status === 'N/A') {
                 document.getElementById('manual-my-total').value = 0;
                 document.getElementById('manual-my-total').disabled = true;
            } else { // Custom Split or other
                 document.getElementById('manual-my-total').disabled = false;
            }
            
            // Add Delete button for existing transactions
            const deleteButton = document.createElement('button');
            deleteButton.id = 'manual-delete-btn';
            deleteButton.classList.add('btn-delete');
            deleteButton.textContent = 'Delete Transaction';
            deleteButton.onclick = () => {
                 // Pass the original index to the delete function
                 deleteTransaction(index); 
                 closeModal('manualTransactionModal'); 
            };
            
            // Insert the delete button *before* the Cancel button
            const cancelButton = actionButtonsContainer.querySelector('.btn-na');
            actionButtonsContainer.insertBefore(deleteButton, cancelButton);


        } else {
            modal.querySelector('h2').textContent = 'Add Manual Transaction';
            modal.dataset.context = 'add';
            document.getElementById('manual-date').valueAsDate = new Date();
            document.getElementById('manual-cc').value = CREDIT_CARD_OPTIONS[CREDIT_CARD_OPTIONS.length - 1]; // Default to 'Manual'
            document.getElementById('manual-desc').value = '';
            document.getElementById('manual-category').value = '';
            document.getElementById('manual-original-amount').value = '';
            document.getElementById('manual-my-total').value = '';
            document.getElementById('manual-notes').value = '';
            
            // Reset split buttons to default state
            document.querySelectorAll('#manual-split-buttons button').forEach(btn => {
                btn.classList.remove('applied');
            });
            // Default to no split status applied for new entry
        }
        
        openModal('manualTransactionModal');
    }
    
    // --- Other Transaction Functions ---
    function renderTransactions() {
        const tbody = document.getElementById('transactions-body');
        tbody.innerHTML = ''; 

        if (displayedTransactions.length === 0) {
             tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; color: #666; padding: 20px;">No transactions match the current filter.</td></tr>';
            return;
        }

        displayedTransactions.forEach((t, index) => {
            // Find the original index to allow editing/deleting from the 'transactions' array
            const originalIndex = transactions.indexOf(t);
            
            const row = tbody.insertRow();
            row.dataset.originalIndex = originalIndex;

            // Date
            row.insertCell().textContent = formatDate(t.date);

            // CC, Description
            row.insertCell().textContent = t.creditCard;
            row.insertCell().textContent = t.description;
            
            // Category (NOW EDITABLE DROPDOWN)
            const categoryCell = row.insertCell();
            categoryCell.innerHTML = `<select class="category-select" style="width: 100%;" onchange="updateTransactionCategory(${originalIndex}, this.value)">
                ${renderCategorySelectOptions(t.category)}
            </select>`;

            // Amounts
            const originalCell = row.insertCell();
            originalCell.textContent = formatCurrency(t.originalAmount);
            originalCell.style.color = t.originalAmount < 0 ? 'black' : 'green'; 

            const myTotalCell = row.insertCell();
            myTotalCell.textContent = formatCurrency(t.myTotal);
            myTotalCell.style.color = t.myTotal < 0 ? 'black' : 'green'; 
            
            // Actions
            const actionCell = row.insertCell();
            actionCell.classList.add('actions');

            if (t.fileName === 'Manual Entry') {
                // Manual entries: ONLY show View/Edit button (as requested)
                actionCell.innerHTML = `
                    <div class="action-buttons-grid single-button">
                        <button class="btn-full" style="background-color: #2473BC !important;"
                                onclick="openManualTransactionModal(${originalIndex})">View/Edit</button>
                    </div>
                `;
            } else {
                // Imported transactions: Show split buttons (as usual)
                // The order: Half, Full (top row) -> Custom, N/A (bottom row) is achieved by the CSS grid-template-columns: 1fr 1fr;
                actionCell.innerHTML = `
                    <div class="action-buttons-grid">
                        <button class="btn-split-half action-button ${t.status === 'Half' || t.status === 'Split Half' ? 'applied' : ''}" 
                                onclick="applySplitAction(${originalIndex}, 'half')">Half</button>
                        <button class="btn-full action-button ${t.status === 'Full' ? 'applied' : ''}"
                                onclick="applySplitAction(${originalIndex}, 'full')">Full</button>
                        <button class="btn-split-custom action-button ${t.status === 'Custom Split' ? 'applied' : ''}"
                                onclick="openCustomSplitModal(${originalIndex})">Custom</button>
                        <button class="btn-na action-button ${t.status === 'N/A' ? 'applied' : ''}"
                                onclick="applySplitAction(${originalIndex}, 'na')">N/A</button>
                    </div>
                `;
            }
            
            // Notes
            const notesCell = row.insertCell();
            // Display notes as a read-only field (no onchange listener needed here)
            notesCell.innerHTML = `<input type="text" class="notes-input" value="${t.notes.replace(/"/g, '&quot;')}" readonly>`;


            // Apply gray-out style if N/A
            if (t.status === 'N/A') {
                row.classList.add('na-applied');
            }
        });
    }

    function applySplitAction(index, action) {
        if (index < 0 || index >= transactions.length) return;

        const t = transactions[index];
        const originalAmount = t.originalAmount;
        let newMyTotal = 0;
        let newStatus = '';

        if (action === 'half') {
            newMyTotal = originalAmount / 2;
            newStatus = 'Half';
        } else if (action === 'full') {
            newMyTotal = originalAmount;
            newStatus = 'Full';
        } else if (action === 'na') {
            newMyTotal = 0;
            newStatus = 'N/A';
        } else {
            return; // Should not happen
        }

        t.myTotal = newMyTotal;
        t.status = newStatus;

        applyDateFilter(); // Re-render transactions and recalculate totals
        applyBreakdownFilter(); // Update breakdown
    }
    
    function openModal(id) {
        document.getElementById(id).style.display = 'block';
    }

    function closeModal(id) {
        document.getElementById(id).style.display = 'none';
    }
    
    function handleManualSplitAction(action) {
        const originalAmountInput = document.getElementById('manual-original-amount');
        const myTotalInput = document.getElementById('manual-my-total');
        const originalAmount = parseFloat(originalAmountInput.value) || 0;
        
        // Remove 'applied' class from all buttons
        document.querySelectorAll('#manual-split-buttons button').forEach(btn => btn.classList.remove('applied'));
        
        // Apply logic based on action
        if (action === 'half') {
            myTotalInput.value = (originalAmount / 2).toFixed(2);
            myTotalInput.disabled = true;
            document.querySelector('[data-action="half"]').classList.add('applied');
        } else if (action === 'full') {
            myTotalInput.value = originalAmount.toFixed(2);
            myTotalInput.disabled = true;
            document.querySelector('[data-action="full"]').classList.add('applied');
        } else if (action === 'na') {
            myTotalInput.value = (0).toFixed(2);
            myTotalInput.disabled = true;
            document.querySelector('[data-action="na"]').classList.add('applied');
        } else if (action === 'custom') {
            myTotalInput.disabled = false;
            document.querySelector('[data-action="custom"]').classList.add('applied');
            // Do not auto-set myTotal for custom split, rely on user input
        }
    }
    
    function handleManualAmountChange() {
        const appliedBtn = document.querySelector('#manual-split-buttons button.applied');
        if (appliedBtn) {
            handleManualSplitAction(appliedBtn.dataset.action);
        }
    }

    function handleManualMyTotalInput() {
        // If the user manually edits My Total, switch the status to 'Custom Split'
        const customBtn = document.querySelector('[data-action="custom"]');
        if (!customBtn.classList.contains('applied')) {
             document.querySelectorAll('#manual-split-buttons button').forEach(btn => btn.classList.remove('applied'));
             customBtn.classList.add('applied');
             document.getElementById('manual-my-total').disabled = false;
        }
    }
    
    function openManualCustomSplitModal() {
        // This button acts as a pre-selection for the Custom Split status
        handleManualSplitAction('custom');
    }

    function saveManualTransaction() {
        const date = document.getElementById('manual-date').value;
        const creditCard = document.getElementById('manual-cc').value;
        const description = document.getElementById('manual-desc').value.trim();
        const category = document.getElementById('manual-category').value.trim();
        const originalAmountStr = document.getElementById('manual-original-amount').value;
        const myTotalStr = document.getElementById('manual-my-total').value;
        const notes = document.getElementById('manual-notes').value.trim();

        if (!date || !originalAmountStr) {
            alert('Date and Original Amount are required.');
            return;
        }

        const originalAmount = parseFloat(originalAmountStr);
        let myTotal = parseFloat(myTotalStr);
        
        if (isNaN(originalAmount)) {
            alert('Please enter a valid number for Original Amount.');
            return;
        }
        
        if (isNaN(myTotal)) {
             // If My Total is blank but Original Amount exists, default to 0 for my total for now
             myTotal = 0;
        }

        const appliedBtn = document.querySelector('#manual-split-buttons button.applied');
        let status = appliedBtn ? appliedBtn.dataset.action : 'Full'; // Default to Full if nothing selected
        
        if (status === 'custom') {
            status = 'Custom Split';
        }
        
        // Final sanity check on values based on selected status
        if (status === 'Full') {
             myTotal = originalAmount;
        } else if (status === 'half') {
             myTotal = originalAmount / 2;
             status = 'Half';
        } else if (status === 'na') {
             myTotal = 0;
             status = 'N/A';
        }

        const newTransaction = {
            date: date,
            dateObj: parseDateInput(date),
            description: description,
            category: category || 'Uncategorized',
            creditCard: creditCard,
            originalAmount: originalAmount,
            myTotal: myTotal,
            status: status,
            fileName: 'Manual Entry',
            notes: notes
        };

        if (document.getElementById('manualTransactionModal').dataset.context === 'edit') {
            // Edit existing transaction
            if (editingTransactionIndex !== null) {
                transactions[editingTransactionIndex] = newTransaction;
                
                // If it was a manual entry, ensure the unique category list is updated
                uniqueCategories.clear();
                transactions.forEach(t => {
                    if (t.category) uniqueCategories.add(t.category);
                });
            }
        } else {
            // Add new transaction
            transactions.push(newTransaction);
            uniqueCategories.add(newTransaction.category);
        }

        closeModal('manualTransactionModal');
        reRenderCategoryDropdowns();
        applyDateFilter(); // Re-render and recalculate
    }
    
    function deleteTransaction(index) {
        if (!confirm('Are you sure you want to delete this transaction?')) return;
        
        if (index >= 0 && index < transactions.length) {
            const deletedTxn = transactions.splice(index, 1)[0];
            
            // Re-evaluate unique categories
            uniqueCategories.clear();
            transactions.forEach(t => {
                if (t.category) uniqueCategories.add(t.category);
            });
            
            reRenderCategoryDropdowns();
            applyDateFilter(); // Re-render and recalculate
            applyBreakdownFilter(); // Update breakdown
        }
    }
    
    // --- Other Modal Functions ---
    let transactionIndexToSplit = null; 

    function openCustomSplitModal(index) {
        transactionIndexToSplit = index;
        const t = transactions[index];

        document.getElementById('modal-date').textContent = formatDate(t.date);
        document.getElementById('modal-description').textContent = t.description;
        document.getElementById('modal-category').textContent = t.category;
        document.getElementById('modal-original-amount').textContent = formatCurrency(t.originalAmount);
        
        // Reset to default 2-way even split
        document.getElementById('split-ways').value = 2;
        document.getElementById('split-type').value = 'even';
        document.getElementById('custom-portion-field').style.display = 'none';
        
        openModal('customSplitModal');
    }

    function toggleCustomPortionField() {
        const splitType = document.getElementById('split-type').value;
        const customPortionField = document.getElementById('custom-portion-field');
        if (splitType === 'custom') {
            customPortionField.style.display = 'block';
            document.getElementById('my-custom-portion').value = ''; // Clear custom input
        } else {
            customPortionField.style.display = 'none';
        }
    }

    function applyCustomSplit() {
        if (transactionIndexToSplit === null) return;

        const splitType = document.getElementById('split-type').value;
        const t = transactions[transactionIndexToSplit];
        const originalAmount = t.originalAmount;
        let newMyTotal = 0;

        if (splitType === 'even') {
            const splitWays = parseInt(document.getElementById('split-ways').value);
            if (isNaN(splitWays) || splitWays <= 0) {
                alert('Please enter a valid number of ways to split.');
                return;
            }
            newMyTotal = originalAmount / splitWays;

        } else if (splitType === 'custom') {
            const customPortion = parseFloat(document.getElementById('my-custom-portion').value);
            if (isNaN(customPortion)) {
                alert('Please enter a valid custom portion for your total.');
                return;
            }
            // Ensure portion is not more than the original amount (and handles negative charges correctly)
            if (Math.abs(customPortion) > Math.abs(originalAmount) && originalAmount !== 0) {
                 if (!confirm(`Your custom portion (${formatCurrency(customPortion)}) is greater than the original amount (${formatCurrency(originalAmount)}). Do you want to continue?`)) {
                    return;
                }
            }
            newMyTotal = customPortion;
        }
        
        t.myTotal = newMyTotal;
        t.status = 'Custom Split'; // Mark as custom split

        closeModal('customSplitModal');
        applyDateFilter(); // Re-render transactions and recalculate totals
        applyBreakdownFilter(); // Update breakdown
    }
    
    function validateSplitWays() {
        const input = document.getElementById('split-ways');
        const value = parseInt(input.value);
        if (isNaN(value) || value < 1) {
            input.value = 1; 
        }
        // If split type is even, trigger a mock apply to update modal view
        if (document.getElementById('split-type').value === 'even') {
            // No need to recalculate here, just ensuring positive integer
        }
    }

    // --- CATEGORY BREAKDOWN FILTER FIX ---
    function applyBreakdownFilter() {
        const preset = document.getElementById('breakdown-date-range-preset').value;
        let startDate = null;
        let endDate = null;

        if (preset === 'current_month') {
            const now = new Date();
            let year = now.getFullYear();
            let month = now.getMonth();
            startDate = new Date(year, month, 1);
            endDate = new Date(year, month + 1, 0);
            endDate.setHours(23, 59, 59, 999);
        } else if (preset === 'last_month') {
            const now = new Date();
            let year = now.getFullYear();
            let month = now.getMonth();
            startDate = new Date(year, month - 1, 1);
            endDate = new Date(year, month, 0);
            endDate.setHours(23, 59, 59, 999);
        }
        
        // --- MODIFIED FILTER LOGIC TO INCLUDE ALL TRANSACTIONS ON 'ALL TIME' ---
        const filteredTxns = transactions.filter(t => {
            const date = t.dateObj;
            
            // Check if we are on 'All Time' filter (startDate and endDate are null)
            const isAllTime = !startDate && !endDate;

            // FIX: If date is invalid, include transaction only if we are in 'All Time' view.
            if (!date) {
                return isAllTime;
            }

            // Apply date filtering as normal
            const meetsStart = !startDate || date >= startDate;
            const meetsEnd = !endDate || date <= endDate;

            return meetsStart && meetsEnd;
        });
        // --- END MODIFIED FILTER LOGIC ---


        calculateCategoryBreakdown(filteredTxns);
    }
    // --- END CATEGORY BREAKDOWN FILTER FIX ---

    function exportToCSV() {
        const today = new Date();
        const todayStr = today.toISOString().split('T')[0];
        
        // Define CSV headers
        const csvRows = [
            ['Date', 'Credit Card', 'Description', 'Category', 'Original Amount', 'My Total', 'Split Status', 'Source File', 'Notes'].join(',')
        ];

        transactions.forEach(t => {
            const clean = (text) => `"${String(text).replace(/"/g, '""')}"`;

            const row = [
                // Use t.date (the raw string) instead of formatDate(t.date) 
                // to ensure re-imported dates are parsed correctly.
                clean(t.date), 
                clean(t.creditCard),
                clean(t.description),
                clean(t.category),
                t.originalAmount.toFixed(2), 
                t.myTotal.toFixed(2),
                clean(t.status),
                clean(t.fileName),
                clean(t.notes)
            ];
            csvRows.push(row.join(','));
        });

        const csvString = csvRows.join('\n');
        const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");

        if (link.download !== undefined) { 
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            // MODIFIED: Use the local date string
            link.setAttribute("download", "transaction_export_" + todayStr + ".csv"); 
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } else {
            alert("Your browser does not support downloading files directly. Please copy the data manually.");
        }
    }
    
    // Initial call to set filters and render if data exists (for persistence)
    // Note: If persistence logic was added, it would be called here.
    // For this one-file app, we rely on the user re-importing on load.
    document.addEventListener('DOMContentLoaded', () => {
         applyDateFilter(); 
         applyBreakdownFilter(); 
    });
</script>

</body>
</html>