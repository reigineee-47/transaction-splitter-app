<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transaction Splitter</title>
    <style>
        /* Styling to match Period Tracker V2_13.html */
        *, *::before, *::after {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
              Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif; /* Period App Font */
            margin: 0; 
            padding: 0; 
            background-color: #ffffff; /* Period App Body Background */
            color: #333;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .container {
            /* CHANGES FOR WIDER DESKTOP USE: */
            max-width: none; 
            width: 98%; 
            min-width: 600px; 
            margin: 20px auto;
            /* END CHANGES */

            background-color: #fff;
            padding: 20px;
            border-radius: 8px; 
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); 
            border: 1px solid #cce5ff; 
        }
        h1 {
            /* Style to match the look of the Period App's h2 and header */
            color: #2473BC; 
            border-bottom: 2px solid #76AFE5; 
            padding-bottom: 4px;
            margin-bottom: 1.5rem;
            font-size: 50px; 
            text-align: center;
            font-weight: 700;
        }
        /* --- New #total-container styles for prominence --- */
        #total-container {
            background-color: #eaf3fb; 
            border: 1px solid #cce5ff; 
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 6px; 
            
            display: grid;
            grid-template-columns: 1fr 1fr;
            text-align: center;
            font-weight: 600;
        }
        .total-box {
            display: flex;
            flex-direction: column;
            padding: 10px;
        }
        .total-box.my-share {
            color: #2473BC; /* My Share is primary blue */
            border-right: 1px solid #cce5ff; /* Separator line */
        }
        .total-box.full-total {
            color: #333;
        }
        .total-amount {
            font-size: 2.5em; /* Bigger font for amount */
            font-weight: 700;
            line-height: 1.1;
        }
        .total-label {
            font-size: 0.9em;
            margin-top: 5px;
            color: #666; /* Gray out the label slightly */
        }
        .total-box.my-share .total-label {
            color: #2473BC;
        }
        /* ----------------------------------------------------------------- */
        
        /* --- Import/Export Controls Layout (50/50 Split) --- */
        .controls-wrapper {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px; 
            margin-bottom: 20px;
        }

        /* Removed blue box frame for import/export containers */
        #import-controls-container {
            display: flex; 
            flex-direction: column;
            gap: 10px; 
            padding: 0; 
            border: none; 
            background-color: transparent; 
            border-radius: 6px; 
        }
        
        /* Removed blue box frame for import/export containers */
        #export-frame {
            display: flex;
            flex-direction: column;
            justify-content: center; 
            padding: 0; 
            border: none;
            background-color: transparent;
            border-radius: 6px; 
        }
        
        .import-action-button {
            padding: 12px 20px;
            font-size: 1.1rem;
            background-color: #2473BC;
            color: white;
            width: 100%;
        }

        /* UPDATED STYLING FOR EXPORT BUTTON (Light Blue) */
        #export-frame button {
            padding: 12px 20px;
            font-size: 1.1rem;
            background-color: #CDE6F8; /* Light Blue Background */
            color: #2473BC; /* Primary Blue Text */
            border: 2px solid #76AFE5; /* Border to match the frame */
            width: 100%; 
            height: 100%; 
            margin: 0;
            display: block;
            font-weight: 700;
        }

        /* Hide the actual file input */
        #csv-file-input {
            display: none; 
        }

        /* --- Tab Styling --- */
        .tabs {
            display: flex;
            border-bottom: 2px solid #76AFE5;
            margin-bottom: 20px;
        }
        .tab-button {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            background-color: #f8fbfe;
            color: #2473BC;
            font-weight: 600;
            transition: all 0.2s;
        }
        .tab-button.active {
            border-color: #76AFE5;
            border-bottom: 2px solid white; 
            background-color: white;
            color: #2473BC;
            margin-bottom: -2px; 
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        
        /* --- NEW STYLES FOR TRANSACTION HEADER CONTROLS (Filters + Add Button) --- */
        .transactions-header-controls {
            display: flex; 
            justify-content: space-between; /* Push button to the right */
            align-items: center; /* Vertically align items */
            margin-bottom: 20px;
            gap: 20px; /* Space between filter section and button */
        }

        /* Style the filter section for existing elements */
        #filter-presets {
            display: flex;
            align-items: center;
            gap: 10px; /* Space between filter elements */
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }
        
        /* Style the new button to match the size of a select/input */
        #add-transaction-btn {
            padding: 10px 20px; /* Similar to select padding */
            font-size: 0.95rem; /* Similar to select font size */
            background-color: #2473BC; /* Primary blue color */
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            /* FIX: Ensure width is determined by content only and it doesn't grow */
            width: auto; 
            flex-grow: 0; 
        }
        
        #category-controls {
            display: flex; 
            gap: 10px;
        }
        
        #add-category-btn {
            padding: 10px 15px; 
            font-size: 0.95rem; 
            background-color: #CDE6F8; 
            color: #2473BC; 
            border: 1px solid #76AFE5; 
            border-radius: 6px; 
            font-weight: 600;
            width: auto; 
            flex-grow: 0; 
        }
        /* --- END NEW STYLES --- */


        /* --- Table Styling and Sorting --- */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: left;
            vertical-align: middle; 
        }
        th {
            background-color: #79AFDE; 
            color: white;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        /* Clickable headers */
        th.sortable {
            cursor: pointer;
            position: relative;
        }
        th.sortable::after {
            content: '';
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            border: 4px solid transparent;
            opacity: 0.5;
        }
        th.sortable.asc::after {
            content: '▲';
            opacity: 1;
            font-size: 0.7em;
            right: 5px;
        }
        th.sortable.desc::after {
            content: '▼';
            opacity: 1;
            font-size: 0.7em;
            right: 5px;
        }

        tr:nth-child(even) {
            background-color: #f8fbfe; 
        }

        /* Gray-out style for N/A rows */
        .na-applied td {
            color: #989898; 
            font-style: italic;
        }
        
        .notes-input {
            width: 100%;
            padding: 4px 6px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 0.85rem;
        }

        /* --- Buttons and Modals --- */
        .action-buttons-grid, .import-actions-grid {
            display: grid;
            /* MODIFIED: Change to 3 columns for 4 split buttons + 1 edit + 1 delete = 6 items per row */
            grid-template-columns: 1fr 1fr 1fr; 
            gap: 5px;
            width: 100%;
        }
        
        /* NEW: Full width for manual entry actions (1 button only now) */
        .action-buttons-grid.single-button {
             grid-template-columns: 1fr;
        }

        .import-actions-grid {
            grid-template-columns: 1fr 1fr; 
        }
        .cc-buttons-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        .cc-buttons-grid button {
            width: 100%;
            font-size: 1rem;
            padding: 12px 5px;
            background-color: #79AFDE;
            color: white;
            border: none;
        }
        
        button {
            padding: 8px 5px; 
            margin: 0; 
            width: 100%; 
            cursor: pointer;
            border: none;
            border-radius: 6px; 
            font-weight: 600; 
            transition: all 0.2s;
            font-size: 0.9rem; 
            box-sizing: border-box; 
        }

        .btn-full, .btn-split-half, .btn-split-custom, .btn-change-cc { 
            background-color: #79AFDE; 
            color: white; 
        } 
        .btn-na { 
            background-color: #989898; 
            color: white;
        }
        .btn-delete { background-color: #e66666; }

        /* Default state: all buttons are outlines */
        .action-button {
            background-color: transparent !important;
            border: 2px solid #79AFDE; 
            color: #2473BC !important; 
            font-weight: 600;
            padding: 6px 5px; 
        }
        .btn-na.action-button { 
            border-color: #989898; 
            color: #989898 !important;
        }
        
        /* Button for editing manual entries */
        .btn-edit-manual {
            background-color: #CDE6F8 !important; 
            border: 2px solid #76AFE5; 
            color: #2473BC !important;
        }

        /* Action Applied State (Turns into a solid-filled button) */
        .btn-full.applied, .btn-split-half.applied, .btn-split-custom.applied { 
            background-color: #79AFDE !important; 
            color: white !important; 
            border: none;
        }
        
        /* OVERRIDE: Set Full button to the main blue color (#2473BC) when applied */
        .btn-full.applied {
            background-color: #2473BC !important; 
            color: white !important; 
            border: none !important;
        }

        .btn-na.applied { 
            background-color: #989898 !important; 
            color: white !important; 
            border: none;
        }


        .negative { color: black; } 
        .positive { color: green; } 

        select, input[type="number"], input[type="text"], input[type="date"] {
            padding: 8px 10px;
            border-radius: 6px;
            border: 1px solid #cce5ff; 
            margin-right: 10px;
            box-sizing: border-box;
            font-size: 0.95rem;
            min-width: 150px; 
        }

        /* Target all select elements in the table for a small padding */
        .category-select {
            width: 100%;
            padding: 6px 8px; 
            font-size: 0.85rem;
        }
        
        /* --- Modal Styling Updates --- */
        .modal {
            display: none; 
            position: fixed; 
            z-index: 100; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.4); 
        }
        .modal-content {
            background-color: #fefefe;
            margin: 10% auto; 
            padding: 25px;
            border: 1px solid #76AFE5; 
            width: 90%; 
            max-width: 500px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(36, 115, 188, 0.2); 
            position: relative; /* REQUIRED for close-btn positioning */
        }
        
        /* Custom Split Modal Row Spacing */
        .modal-details div, 
        .modal-field {
            margin-bottom: 10px; 
        }
        
        /* Styling for the manual transaction form fields */
        #manualTransactionModal .modal-field {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #manualTransactionModal .modal-field label {
            font-weight: 600;
            font-size: 0.9em;
            color: #333;
        }
        #manualTransactionModal .modal-field input, 
        #manualTransactionModal .modal-field select {
            min-width: 100%;
            box-sizing: border-box;
            margin: 0;
        }
        
        /* Make the modal button row three columns when editing (Save, Delete, Cancel) */
        #manualTransactionModal .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        #manualTransactionModal .modal-buttons button {
            flex: 1;
	        margin-top: 20px;
        }
        
        /* Ensure split buttons in modal don't stretch vertically */
        #manual-split-buttons button {
            height: auto; 
            padding: 6px 5px;
        }


        /* Close button positioning */
        .close-btn {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            position: absolute; 
            top: 10px; 
            right: 15px; 
            cursor: pointer;
            line-height: 1; 
            padding: 0;
            margin: 0;
            background: none; 
        }

        /* --- Checklist Tab Styles (NEW) --- */
        #checklist-container {
            padding: 15px;
            border: 1px solid #cce5ff;
            border-radius: 6px;
            background-color: #f8fbfe;
        }
        .checklist-item {
            display: flex;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #eaf3fb;
            cursor: pointer;
            font-size: 1.1rem;
            color: #333;
            font-weight: 500;
        }
        .checklist-item:last-child {
            border-bottom: none;
        }
        .checklist-item input[type="checkbox"] {
            margin-right: 15px;
            /* Custom size/style for checkbox */
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        .checklist-item.checked label {
            text-decoration: line-through;
            color: #989898;
            font-weight: 400;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Transaction Splitter</h1>

    <div class="controls-wrapper">
        
        <div id="import-controls-container">
            <button class="import-action-button" onclick="triggerFileUpload('new')">Import Transactions</button>
            <button class="import-action-button" onclick="triggerFileUpload('old')">Import Old Data</button>
        </div>

        <div id="export-frame">
            <button onclick="exportToCSV()">Export All Data to CSV</button>
        </div>
        
        <input type="file" id="csv-file-input" accept=".csv" multiple>
    </div>

    <div class="tabs">
        <button class="tab-button active" onclick="openTab('transactions-tab', this)">Transactions</button>
        <button class="tab-button" onclick="openTab('imports-tab', this)">File Imports</button>
        <button class="tab-button" onclick="openTab('category-breakdown-tab', this)">Category Breakdown</button>
        <button class="tab-button" onclick="openTab('checklist-tab', this)">Checklist</button>
    </div>

    <div id="transactions-tab" class="tab-content active">
        <div id="total-container">
            <div class="total-box my-share">
                <span id="full-my-total" class="total-amount">$0.00</span>
                <span class="total-label">My Share</span>
            </div>
            <div class="total-box full-total">
                <span id="full-original-total" class="total-amount">$0.00</span>
                <span class="total-label">Full Total Amount</span>
            </div>
        </div>
        <div id="filter-controls" class="transactions-header-controls">
            <div id="filter-presets">
                <label for="date-range-preset">View Range:</label>
                <select id="date-range-preset" onchange="applyDateFilter()">
                    <option value="current_month">This Month</option>
                    <option value="last_month">Last Month</option>
                    <option value="all_time" selected>All Time</option>
                    <option value="custom">Custom Range</option>
                </select>

                <div id="custom-date-range" style="display: none;">
                    <label for="start-date">Start Date:</label>
                    <input type="date" id="start-date" onchange="applyDateFilter()">
                    
                    <label for="end-date">End Date:</label>
                    <input type="date" id="end-date" onchange="applyDateFilter()">
                </div>
            </div>
            <div id="category-controls">
                <button id="add-transaction-btn" onclick="openEditTransactionModal()">Add Manual Transaction</button>
                <button id="add-category-btn" onclick="openNewCategoryModal()">Add Category</button>
            </div>
        </div>
        <div id="transactions-list">
            <table>
                <thead>
                    <tr>
                        <th style="width: 8%;" class="sortable" data-sort-key="dateObj" onclick="sortTransactions('dateObj')">Date</th>
                        <th style="width: 10%;">Credit Card</th>
                        <th style="width: 20%;">Description</th>
                        <th style="width: 10%;">Category</th>
                        <th style="width: 8%;">Original Amount</th>
                        <th style="width: 8%;">My Total</th>
                        <th style="width: 16%;">Actions</th>
                        <th style="width: 20%;">Notes</th>
                    </tr>
                </thead>
                <tbody id="transactions-body">
                    </tbody>
            </table>
        </div>
    </div>

    <div id="imports-tab" class="tab-content">
        <h2>Imported Files History</h2>
        <div id="imports-list">
            <table>
                <thead>
                    <tr>
                        <th style="width: 40%;">File Name</th>
                        <th style="width: 25%;">Credit Card</th>
                        <th style="width: 15%;">Transactions</th>
                        <th style="width: 20%;">Actions</th>
                    </tr>
                </thead>
                <tbody id="imports-body">
                </tbody>
            </table>
        </div>
    </div>

    <div id="category-breakdown-tab" class="tab-content">
        <h2>Category Breakdown</h2>
        <div id="breakdown-filter-controls">
            <label for="breakdown-date-range-preset">View Range:</label>
            <select id="breakdown-date-range-preset" onchange="applyBreakdownFilter()">
                <option value="current_month">This Month</option>
                <option value="last_month">Last Month</option>
                <option value="all_time" selected>All Time</option>
            </select>
        </div>
        <div id="category-breakdown-list">
            <table>
                <thead>
                    <tr>
                        <th style="width: 20%;">Category</th>
                        <th style="width: 15%;">Transaction Count</th>
                        <th style="width: 15%;" class="sortable" data-sort-key="percentage" onclick="sortBreakdown('percentage')">Percentages</th>
                        <th style="width: 20%;">Total Original Amount</th>
                        <th style="width: 15%;">Total My Share</th>
                        <th style="width: 15%;">Actions</th> </tr>
                </thead>
                <tbody id="breakdown-body">
                    <tr><td colspan="6" style="text-align: center; color: #666; padding: 20px;">Load transactions to see breakdown.</td></tr>
                </tbody>
                <tfoot id="breakdown-footer"></tfoot>
            </table>
        </div>
    </div>
    
    <div id="checklist-tab" class="tab-content">
        <h2>Manual Payments Checklist</h2>
        <div id="checklist-container">
            </div>
        <div style="margin-top: 20px;">
            <button class="btn-delete" onclick="clearCompletedChecklist()">Clear completed checklist</button>
        </div>
    </div>
    </div>

<div id="creditCardSelectModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('creditCardSelectModal')">&times;</span>
        <h2 id="cc-modal-title">Select Credit Card for Imported File</h2>
        <p>Please choose which credit card these transactions are from:</p>
        <div id="cc-buttons-container" class="cc-buttons-grid">
            </div>
    </div>
</div>

<div id="changeCCModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('changeCCModal')">&times;</span>
        <h2 id="reassign-cc-title">Reassign Credit Card</h2>
        <p>Select a new card for: <strong id="reassign-file-name"></strong></p>
        <div id="reassign-buttons-container" class="cc-buttons-grid">
            </div>
    </div>
</div>

<div id="customSplitModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('customSplitModal')">&times;</span>
        <h2>Custom Split: Set My Total</h2>

        <div class="modal-details">
            <div><strong>Date:</strong> <span id="modal-date"></span></div>
            <div><strong>Description:</strong> <span id="modal-description"></span></div>
            <div><strong>Category:</strong> <span id="modal-category"></span></div>
            <div><strong>Original Amount:</strong> <span id="modal-original-amount" style="font-weight: bold;">$0.00</span></div>
        </div>

        <div class="modal-field">
            <label style="font-weight: 600;">Transaction Type:</label>
            <div style="display: flex; gap: 20px;">
                <label><input type="radio" name="custom-type" value="transaction" checked> Transaction (Expense)</label>
                <label><input type="radio" name="custom-type" value="refund"> Refund (Credit)</label>
            </div>
        </div>
        
        <div class="modal-field">
            <label for="custom-amount-input" style="font-weight: 600;">Amount to Assign to My Total (Positive Number Only):</label>
            <input type="number" id="custom-amount-input" placeholder="e.g., 55.75" step="0.01" min="0">
        </div>

        <div class="modal-buttons">
            <button onclick="applyCustomSplit()" class="btn-full" style="margin-bottom: 10px; margin-top:25px;">Apply Custom Amount</button>
            <button onclick="closeModal('customSplitModal')" class="btn-na">Cancel</button>
        </div>
    </div>
</div>
<div id="manualTransactionModal" class="modal" data-context="add">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('manualTransactionModal')">&times;</span>
        <h2>Add Manual Transaction</h2>
        
        <div class="modal-field">
            <label for="manual-date">Date <span style="color: red;">*</span></label>
            <input type="date" id="manual-date" required>
        </div>

        <div class="modal-field">
            <label for="manual-cc">Credit Card</label>
            <select id="manual-cc"></select>
        </div>
        
        <div class="modal-field">
            <label for="manual-desc">Description</label>
            <input type="text" id="manual-desc">
        </div>
        
        <div class="modal-field">
            <label for="manual-category">Category</label>
            <select id="manual-category" class="category-select"></select>
        </div>

        <div class="modal-field">
            <label for="manual-original-amount">Original Amount ($) <span style="color: red;">*</span></label>
            <input type="number" id="manual-original-amount" step="0.01" placeholder="e.g., -55.75" required oninput="handleManualAmountChange()">
            <small style="color: #666; margin-top: -5px;">Put minus if a transaction is a charge (e.g., -55.75).</small>
        </div>
        
        <div class="modal-field">
            <label>Split Status</label>
            <div id="manual-split-buttons" class="action-buttons-grid">
                <button class="btn-split-half action-button" data-action="half" onclick="handleManualSplitAction('half')">Half</button>
                <button class="btn-full action-button" data-action="full" onclick="handleManualSplitAction('full')">Full</button>
                <button class="btn-split-custom action-button" data-action="custom" onclick="openManualCustomSplitModal()">Custom Split</button>
                <button class="btn-na action-button" data-action="na" onclick="handleManualSplitAction('na')">N/A</button>
            </div>
        </div>
        
        <div class="modal-field">
            <label for="manual-my-total">My Total ($)</label>
            <input type="number" id="manual-my-total" step="0.01" placeholder="e.g., -27.88" oninput="handleManualMyTotalInput()">
        </div>
        
        <div class="modal-field">
            <label for="manual-notes">Notes</label>
            <input type="text" id="manual-notes">
        </div>

        <div class="modal-buttons" id="manual-modal-action-buttons">
            <button onclick="saveManualTransaction()" class="btn-full" id="manual-save-btn">Save Transaction</button>
            <button onclick="closeModal('manualTransactionModal')" class="btn-na">Cancel</button>
        </div>
    </div>
</div>

<div id="newCategoryModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('newCategoryModal')">&times;</span>
        <h2>Add New Category</h2>
        
        <div class="modal-field">
            <label for="new-category-name-input" style="font-weight: 600;">Category Name:</label>
            <input type="text" id="new-category-name-input" placeholder="e.g., Groceries" required>
        </div>

        <div class="modal-buttons" style="margin-top: 20px;">
            <button onclick="addNewCategory()" class="btn-full" style="background-color: #2473BC; margin-bottom: 10px; margin-top:25px;">Add Category</button>
            <button onclick="closeModal('newCategoryModal')" class="btn-na">Cancel</button>
        </div>
    </div>
</div>
<div id="manageCategoryModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('manageCategoryModal')">&times;</span>
        <h2>Manage Category: <strong id="current-category-name-display"></strong></h2>
        
        <p style="font-weight: bold; margin-top: 10px;">Rename Category</p>
        <div class="modal-field">
            <label for="new-category-name">New Name:</label>
            <input type="text" id="new-category-name" placeholder="Enter new category name">
        </div>
        
        <div class="modal-buttons" style="margin-bottom: 25px;">
            <button onclick="performRenameCategory()" class="btn-full" id="rename-category-btn" style="background-color: #2473BC;">Rename Category</button>
        </div>
        
        <hr style="border-top: 1px solid #cce5ff; margin: 15px 0;">
        
        <p style="font-weight: bold; color: #e66666; margin-bottom: 10px;">Danger Zone: Delete Category</p>
        <div class="modal-buttons">
            <button onclick="deleteCategory(currentManagingCategory)" class="btn-delete">Delete & Re-categorize to 'Uncategorized'</button>
        </div>
        <small style="color: #989898; margin-top: 5px; display: block;">This action cannot be undone.</small>

        <div class="modal-buttons" style="margin-top: 20px;">
            <button onclick="closeModal('manageCategoryModal')" class="btn-na">Close</button>
        </div>
    </div>
</div>
<script>
    // Global Constants
    const CREDIT_CARD_OPTIONS = [
        'Unlimited 3993', 
        'Sapphire 8906', 
        'Target', 
        'My CC',
        'Manual' // Added 'Manual' as a default CC option for manual entries
    ];
    // FIX: Define the missing constant used in parseCSV to exclude categories
    const EXCLUDED_CATEGORIES = ["credit card payments", "transfers"];
    // Special value to signal that card selection was skipped and to look in CSV
    const SKIP_CC_SELECTION = 'OLD_DATA_AUTO_ASSIGN'; 
    
    // Special ID for manual entries, which are now hidden from the imports list
    const MANUAL_ENTRY_ID = 0; 
    
    // Global variables
    let transactions = []; 
    let displayedTransactions = []; 
    let uniqueCategories = new Set();
    let fullOriginalTotal = 0;
    let fullMyTotal = 0;
    let currentTransactionIndex = null; 
    let editingTransactionIndex = null; 
    let currentManagingCategory = null; 
    
    // Sorting State
    let transactionSort = { key: 'dateObj', direction: 'asc' }; 
    let breakdownSort = { key: 'percentage', direction: 'desc' };
    
    // Data structures for file management
    let filesToProcess = []; 
    let currentProcessingFile = null; 
    let importedFilesHistory = []; 
    let reassigningFileIndex = null; 
    let currentImportType = 'new'; // 'new' or 'old'
    let currentBreakdownData = []; // To hold the category data for sorting

    // NEW CHECKLIST CONSTANTS AND DATA STRUCTURE
    const CHECKLIST_ITEMS = [
        "Sapphire", 
        "Unlimited", 
        "Target", 
        "My CC", 
        "Rent ($2046)", 
        "Biko daycare/boarding", 
        "Electricity (APS)"
    ];
    const CHECKLIST_STORAGE_KEY = 'transactionSplitterChecklist';
    let checklistState = {}; // Stores the checked/unchecked state for persistence
    // END NEW CHECKLIST CONSTANTS AND DATA STRUCTURE

    // Event listener for the actual file input (now hidden)
    document.getElementById('csv-file-input').addEventListener('change', initializeFileUpload);
    document.getElementById('date-range-preset').addEventListener('change', applyDateFilter);
    document.getElementById('breakdown-date-range-preset').addEventListener('change', applyBreakdownFilter);

    // Initial setup of CC buttons in the two modals AND the CC dropdown in manual entry modal
    (function setupCCButtons() {
        const container = document.getElementById('cc-buttons-container');
        const reassignContainer = document.getElementById('reassign-buttons-container');
        const manualCCSelect = document.getElementById('manual-cc');
        
        CREDIT_CARD_OPTIONS.forEach(cardName => {
            // Initial Import Modal Buttons
            const btn1 = document.createElement('button');
            btn1.textContent = cardName;
            btn1.onclick = () => handleCreditCardSelection(cardName);
            container.appendChild(btn1);

            // Reassign CC Modal Buttons
            const btn2 = document.createElement('button');
            btn2.textContent = cardName;
            btn2.onclick = () => reassignCreditCard(reassigningFileIndex, cardName);
            reassignContainer.appendChild(btn2);
            
            // Manual Entry CC Dropdown Options
            const option = document.createElement('option');
            option.value = cardName;
            option.textContent = cardName;
            manualCCSelect.appendChild(option);
        });
        // Default the manual entry dropdown to the last option ('Manual') or first option
        manualCCSelect.value = 'Manual'; 
    })();
    
    // --- Utility Functions ---
    
    // Helper function to parse date strings and prevent timezone issues
    function parseDateInput(dateString) {
        // Appends T12:00:00 to treat the date as noon local time, mitigating timezone shifts
        if (!dateString) return null;
        // Check for common formats and handle them, but mostly rely on T12:00:00
        const datePart = dateString.split('T')[0];
        
        // This attempts to parse the date as a date string plus a time offset 
        // to prevent it from being interpreted as UTC midnight (which shifts the day).
        let date = new Date(datePart + 'T12:00:00');
        
        // Fallback for non-standard formats that the above logic might fail, but still need the local fix.
        // This is important for re-importing old, formatted dates.
        if (isNaN(date.getTime())) {
            date = new Date(dateString + 'T12:00:00');
        }

        // Final fallback on the raw string for very ambiguous formats
        if (isNaN(date.getTime())) {
            date = new Date(dateString);
        }
        
        return isNaN(date.getTime()) ? null : date;
    }
    
    function formatDate(dateString) {
        const date = parseDateInput(dateString); // Use parseDateInput to get a valid date
        if (date === null) return dateString; // Return original string if unparsable
        const options = { year: 'numeric', month: 'short', day: 'numeric' };
        return date.toLocaleDateString('en-US', options);
    }
    
    function formatCurrency(amount) {
        return new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: 'USD'
        }).format(amount);
    }
    
    function updateTotalsDisplay() {
        document.getElementById('full-original-total').textContent = formatCurrency(fullOriginalTotal);
        document.getElementById('full-my-total').textContent = formatCurrency(fullMyTotal);
    }
    
    function closeModal(id) {
        document.getElementById(id).style.display = 'none';
        if (id === 'customSplitModal') {
            currentTransactionIndex = null;
        } else if (id === 'manualTransactionModal') {
            editingTransactionIndex = null;
        }
    }
    
    function openModal(id) {
        document.getElementById(id).style.display = 'block';
    }

    window.onclick = function(event) {
        const customSplitModal = document.getElementById('customSplitModal');
        const ccSelectModal = document.getElementById('creditCardSelectModal');
        const changeCCModal = document.getElementById('changeCCModal');
        const manualTxnModal = document.getElementById('manualTransactionModal');
        const manageCatModal = document.getElementById('manageCategoryModal');
        const newCatModal = document.getElementById('newCategoryModal'); 
        
        if (event.target == customSplitModal) {
            closeModal('customSplitModal');
        } else if (event.target == ccSelectModal) {
            closeModal('creditCardSelectModal');
        } else if (event.target == changeCCModal) {
             closeModal('changeCCModal');
        } else if (event.target == manualTxnModal) {
             closeModal('manualTransactionModal');
        } else if (event.target == manageCatModal) {
             closeModal('manageCategoryModal');
        } else if (event.target == newCatModal) { 
             closeModal('newCategoryModal');
        }
    }

    // NEW FUNCTION: Calculates totals based on currently filtered/displayed transactions
    function calculateTotals() {
        fullOriginalTotal = 0;
        fullMyTotal = 0;

        // Define categories to exclude from the My Share total calculation (case-insensitive)
        const myShareExcludedCategories = new Set([
            "credit card payments",
            "transfers",
            "my payments"
        ]);
        
        // Define categories to exclude from the Full Total calculation
        // This is the V7 logic being reapplied to fix the grand total amount.
        const fullTotalExcludedCategories = new Set([
            "my payments" // Exclude 'my payments' from the Full Total sum
        ]);
        
        displayedTransactions.forEach(t => {
            // 1. Calculate Full Original Total (Excluding 'My Payments' which are positive credits/deposits)
            if (!fullTotalExcludedCategories.has(t.category.toLowerCase())) {
                fullOriginalTotal += t.originalAmount; 
            }

            // 2. Calculate My Share Total 
            // Only include in My Total if the category is NOT in the excluded list
            if (!myShareExcludedCategories.has(t.category.toLowerCase())) {
                fullMyTotal += t.myTotal;
            } else {
                // We do nothing if it's excluded, as handled by the IF above.
            }
        });
        
        updateTotalsDisplay();
    }
    
    // NEW FUNCTION - CORE FIX: Re-sorts displayedTransactions using the current global sort state.
    // Does NOT flip the direction, thus preserving the user's view.
    function reapplyCurrentSort() {
        const key = transactionSort.key;
        const direction = transactionSort.direction;
        
        displayedTransactions.sort((a, b) => {
            const aVal = a[key];
            const bVal = b[key];
            let comparison = 0;

            if (key === 'dateObj') {
                const aTime = aVal ? aVal.getTime() : 0;
                const bTime = bVal ? bVal.getTime() : 0;
                comparison = aTime - bTime;
            } else if (typeof aVal === 'number' && typeof bVal === 'number') {
                comparison = aVal - bVal;
            } else {
                // Handle null/undefined values gracefully
                const strA = String(aVal || '');
                const strB = String(bVal || '');
                comparison = strA.localeCompare(strB);
            }
            
            return direction === 'asc' ? comparison : -comparison;
        });
        
        updateSortIndicators('transactions-list', transactionSort);
        renderTransactions();
    }
    
    // --- End Utility Functions ---

    // --- Trigger File Input ---
    function triggerFileUpload(type) {
        currentImportType = type;
        document.getElementById('csv-file-input').click();
    }
    
    // --- Tab Switching ---
    function openTab(tabId, element) {
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
        document.querySelectorAll('.tab-button').forEach(button => button.classList.remove('active'));
        document.getElementById(tabId).classList.add('active');
        element.classList.add('active');
        if (tabId === 'imports-tab') { 
            renderImportsHistory(); 
        } else if (tabId === 'category-breakdown-tab') { 
            applyBreakdownFilter(); // Trigger calculation on tab switch 
        } else if (tabId === 'checklist-tab') { // NEW: Checklist tab load
            loadChecklistState();
        }
    }
    
    // --- File Handling Functions ---
    function initializeFileUpload(event) {
        const fileList = event.target.files;
        if (fileList.length > 0) {
            filesToProcess.push(...Array.from(fileList));
            event.target.value = null;
            processNextFileInQueue();
        }
    }
    function processNextFileInQueue() {
        if (filesToProcess.length > 0) {
            currentProcessingFile = filesToProcess.shift();
            if (currentImportType === 'old') {
                // SKIP CC MODAL for old data. Pass the skip constant.
                handleCreditCardSelection(SKIP_CC_SELECTION);
            } else {
                // Regular process: show modal for new data
                document.getElementById('cc-modal-title').textContent = `Select Card for: ${currentProcessingFile.name}`;
                openModal('creditCardSelectModal');
            }
        } else {
            processTransactions();
        }
    }
    function handleCreditCardSelection(selectedCard) {
        // Hide modal if it was open (including if the selection was a skip)
        closeModal('creditCardSelectModal'); 
        
        if (!currentProcessingFile) {
            console.error("No file to process after card selection.");
            return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
            const content = e.target.result;
            const cardForAssignment = selectedCard === SKIP_CC_SELECTION ? null : selectedCard;
            const newTransactions = parseCSV(
                content, 
                currentProcessingFile.name, 
                cardForAssignment, 
                currentImportType
            );
            
            transactions.push(...newTransactions);
            
            // If the card was auto-assigned (old data or auto-detected in CSV)
            const finalCard = cardForAssignment || newTransactions[0]?.creditCard || 'Unknown';

            // Only add to history if it's a real file import
            if (currentProcessingFile.name !== 'Manual Entry') {
                // If it's a file with no transactions, don't add to history
                if (newTransactions.length > 0) {
                    // Check if a file with the same name already exists
                    const existingFile = importedFilesHistory.find(f => f.fileName === currentProcessingFile.name);
                    
                    if (existingFile) {
                        // If it exists, update its details
                        existingFile.creditCard = finalCard;
                        existingFile.transactionCount += newTransactions.length;
                    } else {
                        // If it's new, add it to the history
                        importedFilesHistory.push({
                            id: importedFilesHistory.length + 1, // Simple unique ID for file
                            fileName: currentProcessingFile.name,
                            creditCard: finalCard,
                            transactionCount: newTransactions.length,
                            dateAdded: new Date().toLocaleDateString()
                        });
                    }
                }
            }

            currentProcessingFile = null;
            processNextFileInQueue();
        };
        reader.readAsText(currentProcessingFile);
    }
    function parseCSV(csvString, fileName, selectedCard, importType) {
        // ... (existing parseCSV function content) ...
        const lines = csvString.split('\n').map(line => line.trim()).filter(line => line.length > 0);
        if (lines.length === 0) return [];

        const headerLine = lines[0];
        const dataLines = lines.slice(1);
        
        const parseLine = (line) => {
            const result = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result;
        }

        const headers = parseLine(headerLine);
        // Map header names to their column index
        const headerMap = headers.reduce((acc, header, index) => {
            const cleanCol = header.trim().toLowerCase();
            acc[cleanCol] = index;
            // Catch variations of credit card column
            if (cleanCol.includes('credit card') || cleanCol.includes('cc') || cleanCol.includes('card name') || cleanCol.includes('account')) {
                acc['credit card from csv'] = index;
            }
            return acc;
        }, {});

        const dateIndex = headerMap['date'];
        const descIndex = headerMap['description'];
        const categoryIndex = headerMap['category'];
        // Check for 'amount' first, then fallback to 'original amount' for compatibility
        const amountIndex = headerMap['amount'] !== undefined ? headerMap['amount'] : headerMap['original amount'];
        const ccCsvIndex = headerMap['credit card from csv'];

        // INDICES FOR RE-IMPORTING OLD/EXPORTED DATA
        const myTotalIndex = headerMap['my total'];
        const statusIndex = headerMap['split status'];
        const notesIndex = headerMap['notes'];

        if (dateIndex === undefined || amountIndex === undefined) {
            alert(`File "${fileName}" skipped: CSV must contain 'Date' and one of 'Amount' or 'Original Amount' columns (case-insensitive).`);
            return [];
        }

        const parsedData = [];
        dataLines.forEach(line => {
            const values = parseLine(line);
            if (values.length > 0) {
                const amountStr = values[amountIndex] || '0';
                // Remove non-numeric characters except for '-' and '.'
                const originalAmount = parseFloat(amountStr.replace(/[^0-9.-]/g, '')); 

                // Skip zero-amount transactions (which can sometimes be artifacts)
                if (isNaN(originalAmount) || originalAmount === 0) return; 

                // Assign credit card
                let finalCreditCard = selectedCard || 'Unknown';
                if (selectedCard === null && ccCsvIndex !== undefined) {
                    finalCreditCard = (values[ccCsvIndex] || 'Unknown').trim();
                }

                // If importing "old" data, pull myTotal, status, and notes from CSV
                let myTotal = 0;
                let status = '';
                let notes = '';
                let category = (values[categoryIndex] || 'Uncategorized').trim();

                if (importType === 'old' && myTotalIndex !== undefined && statusIndex !== undefined) {
                    const myTotalStr = values[myTotalIndex] || '0';
                    myTotal = parseFloat(myTotalStr.replace(/[^0-9.-]/g, ''));
                    status = (values[statusIndex] || '').trim();
                    notes = (values[notesIndex] || '').trim();
                }

                // If importing "new" data (no myTotal/status columns), set sensible defaults
                if (importType === 'new' || status === '') {
                    // Default behavior for new transactions: full share if it's an expense,
                    // and half share if it's a credit (or a zero value, though zero should typically be filtered earlier).
                    if (originalAmount <= 0) {
                        // Expense or zero, set to Half by default
                        status = 'Half';
                        myTotal = originalAmount / 2;
                    } else {
                        // Credit (like a refund or a deposit), set to Full by default
                        status = 'Full';
                        myTotal = originalAmount;
                    }
                }

                const dateString = (values[dateIndex] || '').trim();
                const dateObj = parseDateInput(dateString);
                
                // Exclude transactions with excluded categories (like credit card payments)
                if (EXCLUDED_CATEGORIES.includes(category.toLowerCase())) {
                    return; 
                }
                
                parsedData.push({
                    id: Date.now() + parsedData.length, // Simple unique ID
                    date: dateString,
                    dateObj: dateObj, // Date object for sorting/filtering
                    creditCard: finalCreditCard,
                    description: (values[descIndex] || 'N/A').trim(),
                    category: category,
                    originalAmount: originalAmount, // Parsed value or default 0
                    myTotal: myTotal, // Set to parsed value or default 0
                    status: status, // Set to parsed value or default ''
                    fileName: fileName,
                    notes: notes // Set to parsed value or default ''
                });
            }
        });

        if (parsedData.length === 0 && dataLines.length > 0) {
            console.warn(`Warning: Found data rows in "${fileName}" but parsed 0 transactions. Check CSV format.`);
        }
        return parsedData;
    }
    function processTransactions() {
        // Initial sort: Date ASC
        transactions.sort((a, b) => {
            if (!a.dateObj) return 1;
            if (!b.dateObj) return -1;
            return a.dateObj.getTime() - b.dateObj.getTime();
        });
        transactions.forEach(t => {
            if (t.category) uniqueCategories.add(t.category);
        });
        reRenderCategoryDropdowns();
        applyDateFilter();
    }
    // --- Transaction Sorting and Filtering Functions ---
    function updateSortIndicators(containerId, sortState) {
        document.querySelectorAll(`#${containerId} th.sortable`).forEach(th => {
            th.classList.remove('asc', 'desc');
            if (th.dataset.sortKey === sortState.key) {
                th.classList.add(sortState.direction);
            }
        });
    }
    function sortTransactions(key) {
        if (transactionSort.key === key) {
            transactionSort.direction = transactionSort.direction === 'asc' ? 'desc' : 'asc';
        } else {
            transactionSort.key = key;
            transactionSort.direction = key === 'dateObj' ? 'asc' : 'desc'; // Default newest date first, or largest amount first (desc)
        }
        reapplyCurrentSort();
    }
    function applyDateFilter() {
        const preset = document.getElementById('date-range-preset').value;
        const customRangeDiv = document.getElementById('custom-date-range');
        let startDate = null;
        let endDate = null;

        if (preset === 'custom') {
            customRangeDiv.style.display = 'flex';
            startDate = document.getElementById('start-date').value ? parseDateInput(document.getElementById('start-date').value) : null;
            endDate = document.getElementById('end-date').value ? parseDateInput(document.getElementById('end-date').value) : null;
            // Add one day to the end date to make it inclusive until the end of that day
            if (endDate) {
                endDate.setDate(endDate.getDate() + 1);
                endDate.setSeconds(endDate.getSeconds() - 1); // Set to 23:59:59
            }
        } else {
            customRangeDiv.style.display = 'none';
            const now = new Date();
            let start = new Date(now.getFullYear(), now.getMonth(), 1);
            let end = new Date(now.getFullYear(), now.getMonth() + 1, 0); // Last day of month
            if (preset === 'last_month') {
                start = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                end = new Date(now.getFullYear(), now.getMonth(), 0); // Last day of last month
            } else if (preset === 'all_time') {
                // FIX: For 'all_time', we explicitly set startDate and endDate to null
                // and then continue with the filtering, which will pass all dates.
                // No further date manipulation is needed.
                startDate = null;
                endDate = null;
            }

            // Only set the dates if the preset is NOT 'all_time'
            if (preset !== 'all_time') {
                startDate = start; 
                // Add one day to the end date to make it inclusive until the end of that day
                endDate = new Date(end.getFullYear(), end.getMonth(), end.getDate() + 1);
                endDate.setSeconds(endDate.getSeconds() - 1); // Set to 23:59:59
            }
        }
        
        displayedTransactions = transactions.filter(t => {
            const date = t.dateObj;
            if (!date) return false; // Filter out transactions with invalid dates
            const meetsStart = !startDate || date >= startDate;
            const meetsEnd = !endDate || date <= endDate;
            return meetsStart && meetsEnd;
        });

        reapplyCurrentSort();
        calculateTotals();
    }

    // --- Render Functions ---
    function getActionButtonsHTML(t, index) {
        const status = t.status || '';
        const isNA = status === 'N/A';
        const isFull = status === 'Full';
        const isHalf = status === 'Half';
        const isCustom = status === 'Custom Split';
        
        const naClass = isNA ? 'applied' : 'action-button';
        const fullClass = isFull ? 'applied' : 'action-button';
        const halfClass = isHalf ? 'applied' : 'action-button';
        const customClass = isCustom ? 'applied' : 'action-button';

        // Only manual entries get an 'Edit' button
        const isManual = t.fileName === 'Manual Entry'; 
        const manualEditButtonHTML = isManual 
            ? `<button class="btn-edit-manual action-button" onclick="openEditTransactionModal(${index})">Edit</button>` 
            : '';
        
        // If it's a manual entry, show a single button grid for edit/delete
        if (isManual) {
            return `
                <div class="action-buttons-grid single-button">
                    ${manualEditButtonHTML}
                    <button class="btn-delete" onclick="deleteTransaction(${index})">Delete</button>
                </div>
            `;
        }

        // For imported entries, show the split buttons
        return `
            <div class="action-buttons-grid">
                <button class="btn-split-half action-button ${halfClass}" onclick="applySplitHalf(${index})">Half</button>
                <button class="btn-full action-button ${fullClass}" onclick="applySplitFull(${index})">Full</button>
                <button class="btn-split-custom action-button ${customClass}" onclick="openCustomSplitModal(${index})">Custom</button>
                <button class="btn-na action-button ${naClass}" onclick="applySplitNA(${index})">N/A</button>
                ${manualEditButtonHTML}
                <button class="btn-delete" onclick="deleteTransaction(${index})">Delete</button>
            </div>
        `;
    }
    function renderTransactions() {
        const tbody = document.getElementById('transactions-body');
        tbody.innerHTML = '';
        if (displayedTransactions.length === 0) {
            tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; color: #666; padding: 20px;">No transactions match the current filter.</td></tr>';
            updateTotalsDisplay();
            return;
        }

        displayedTransactions.forEach((t, index) => {
            const row = tbody.insertRow();
            row.classList.toggle('na-applied', t.status === 'N/A');

            // Date, Credit Card, Description
            row.insertCell().textContent = formatDate(t.date);
            row.insertCell().textContent = t.creditCard;
            row.insertCell().textContent = t.description;

            // Category (Dropdown)
            const categoryCell = row.insertCell();
            const categorySelect = document.createElement('select');
            categorySelect.className = 'category-select';
            categorySelect.dataset.index = index;
            categorySelect.onchange = (e) => updateTransactionCategory(index, e.target.value);

            // Populate the category dropdown
            const categoriesArray = Array.from(uniqueCategories).sort();
            const allCategories = ['Uncategorized', ...categoriesArray.filter(cat => cat !== 'Uncategorized')];
            allCategories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat;
                option.textContent = cat;
                if (t.category === cat) {
                    option.selected = true;
                }
                categorySelect.appendChild(option);
            });
            categoryCell.appendChild(categorySelect);

            // Original Amount & My Total
            const originalAmountCell = row.insertCell();
            originalAmountCell.textContent = formatCurrency(t.originalAmount);
            originalAmountCell.classList.add(t.originalAmount < 0 ? 'negative' : 'positive');
            
            const myTotalCell = row.insertCell();
            myTotalCell.textContent = formatCurrency(t.myTotal);
            myTotalCell.classList.add(t.myTotal < 0 ? 'negative' : 'positive');

            // Actions (Buttons)
            const actionsCell = row.insertCell();
            actionsCell.innerHTML = getActionButtonsHTML(t, index);

            // Notes (Input)
            const notesCell = row.insertCell();
            const notesInput = document.createElement('input');
            notesInput.type = 'text';
            notesInput.className = 'notes-input';
            notesInput.value = t.notes || '';
            notesInput.onchange = (e) => updateTransactionNotes(index, e.target.value);
            notesCell.appendChild(notesInput);
        });

        // Ensure totals are correct after rendering the potentially filtered list
        calculateTotals();
    }
    
    // --- Action Functions ---
    function openCustomSplitModal(index) {
        currentTransactionIndex = index;
        const t = displayedTransactions[index];
        if (!t) return;

        document.getElementById('modal-date').textContent = formatDate(t.date);
        document.getElementById('modal-description').textContent = t.description;
        document.getElementById('modal-category').textContent = t.category || 'Uncategorized';
        document.getElementById('modal-original-amount').textContent = formatCurrency(t.originalAmount);
        
        // Use the absolute value of the original amount for the placeholder/input hint
        const absoluteAmount = Math.abs(t.originalAmount);
        document.getElementById('custom-amount-input').value = (Math.abs(t.myTotal) || absoluteAmount / 2).toFixed(2);

        // Check the radio button based on the original amount sign
        document.querySelector(`input[name="custom-type"][value="${t.originalAmount < 0 ? 'transaction' : 'refund'}"]`).checked = true;

        openModal('customSplitModal');
    }
    function applyCustomSplit() {
        const index = currentTransactionIndex;
        const customAmountInput = document.getElementById('custom-amount-input');
        const customValue = parseFloat(customAmountInput.value);
        const transactionType = document.querySelector('input[name="custom-type"]:checked').value;
        closeModal('customSplitModal');

        if (isNaN(customValue) || customValue <= 0) {
            alert('Please enter a valid positive amount.');
            return;
        }

        // Apply the action (which will use the sign from the original amount, but apply the custom magnitude)
        applyAction('custom', index, customValue, transactionType); 
    }
    function applyAction(actionType, index, customValue = null, transactionType = null) {
        const t = displayedTransactions[index];
        if (!t) return;

        // Find the original transaction in the full list to ensure persistence
        const originalTIndex = transactions.findIndex(origT => 
            origT.date === t.date && 
            origT.description === t.description && 
            origT.originalAmount === t.originalAmount && 
            origT.fileName === t.fileName
        );

        // Target the transaction object in the full list for persistence
        const targetT = originalTIndex !== -1 ? transactions[originalTIndex] : t; 
        
        // 1. Update status
        targetT.status = actionType.charAt(0).toUpperCase() + actionType.slice(1);
        if (actionType === 'custom') {
             targetT.status = 'Custom Split';
        }
        
        // 2. Update myTotal based on action and transaction sign
        const sign = t.originalAmount < 0 ? -1 : 1;
        const absOriginalAmount = Math.abs(t.originalAmount);

        switch (actionType) {
            case 'half':
                targetT.myTotal = (absOriginalAmount / 2) * sign;
                break;
            case 'full':
                targetT.myTotal = absOriginalAmount * sign;
                break;
            case 'na':
                targetT.myTotal = 0;
                break;
            case 'custom':
                // Custom value is always positive magnitude. We apply the sign based on the modal radio button (transaction=negative, refund=positive).
                const customSign = transactionType === 'transaction' ? -1 : 1;
                targetT.myTotal = customValue * customSign;
                break;
        }

        // 3. Update the displayed transaction object (to ensure re-render reflects changes)
        Object.assign(t, targetT);
        
        // FIX (part 2 of 2): Recalculate totals and re-render using the existing sort state.
        calculateTotals();
        reapplyCurrentSort();
    }
    function applySplitHalf(index) {
        applyAction('half', index);
    }
    function applySplitFull(index) {
        applyAction('full', index);
    }
    function applySplitNA(index) {
        applyAction('na', index);
    }
    function updateTransactionNotes(index, value) {
        const t = displayedTransactions[index];
        if (t) {
            // Find the original transaction in the full list to ensure persistence
            const originalTIndex = transactions.findIndex(origT => origT.date === t.date && origT.description === t.description && origT.originalAmount === t.originalAmount && origT.fileName === t.fileName);
            const targetT = originalTIndex !== -1 ? transactions[originalTIndex] : t;
            targetT.notes = value;
            t.notes = value; // Also update the displayed one
        }
    }
    function updateTransactionCategory(index, newCategory) {
        const t = displayedTransactions[index];
        if (t) {
            // Find the original transaction in the full list to ensure persistence
            const originalTIndex = transactions.findIndex(origT => origT.date === t.date && origT.description === t.description && origT.originalAmount === t.originalAmount && origT.fileName === t.fileName);
            const targetT = originalTIndex !== -1 ? transactions[originalTIndex] : t;
            
            // 1. Update the original transaction in the full list
            targetT.category = newCategory;
            // 2. Update the displayed transaction
            t.category = newCategory;

            // 3. Recalculate and re-render
            calculateTotals();
            reapplyCurrentSort();
            // Don't need to re-render dropdowns or breakdown here, only on manage/add category
        }
    }
    // --- File History Functions ---
    function renderImportsHistory() {
        const tbody = document.getElementById('imports-body');
        tbody.innerHTML = '';
        
        // Filter out the 'Manual Entry' file which is not managed here
        const filteredHistory = importedFilesHistory.filter(f => f.id !== MANUAL_ENTRY_ID);
        
        if (filteredHistory.length === 0) {
            tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #666; padding: 20px;">No files have been imported yet.</td></tr>';
            return;
        }

        filteredHistory.forEach(file => {
            const row = tbody.insertRow();
            row.insertCell().textContent = file.fileName;
            row.insertCell().textContent = file.creditCard;
            row.insertCell().textContent = file.transactionCount;
            const actionsCell = row.insertCell();
            actionsCell.innerHTML = `
                <div class="import-actions-grid">
                    <button onclick="openReassignModal(${file.id})">Re-assign Card</button>
                    <button class="btn-delete" onclick="deleteImportedFile(${file.id})">Delete</button>
                </div>
            `;
        });
    }
    function openReassignModal(fileId) {
        if (fileId === MANUAL_ENTRY_ID) return; // Cannot reassign the manual entry group
        const fileEntry = importedFilesHistory.find(f => f.id === fileId);
        if (!fileEntry) return;

        reassigningFileIndex = fileId;
        document.getElementById('reassign-file-name').textContent = fileEntry.fileName;

        // Clone and replace the container to wipe out old event listeners and re-attach
        const oldContainer = document.getElementById('reassign-buttons-container');
        const newContainer = oldContainer.cloneNode(true);
        oldContainer.parentNode.replaceChild(newContainer, oldContainer);
        newContainer.id = 'reassign-buttons-container';

        const buttons = newContainer.querySelectorAll('button');
        buttons.forEach(button => {
            const cardName = button.textContent;
            button.onclick = () => reassignCreditCard(fileId, cardName);
        });

        openModal('changeCCModal');
    }
    function reassignCreditCard(fileId, newCard) {
        const fileEntry = importedFilesHistory.find(f => f.id === fileId);
        if (!fileEntry) return;

        transactions.forEach(t => {
            if (t.fileName === fileEntry.fileName) {
                t.creditCard = newCard;
            }
        });
        fileEntry.creditCard = newCard; // Update the history object
        closeModal('changeCCModal');
        // Re-render both the history and transactions list
        renderImportsHistory();
        applyDateFilter();
    }
    function deleteImportedFile(fileId) {
        if (!confirm('Are you sure you want to delete this imported file and all its associated transactions? This action cannot be undone.')) return;

        const fileEntryIndex = importedFilesHistory.findIndex(f => f.id === fileId);
        if (fileEntryIndex === -1) return;
        
        const fileNameToDelete = importedFilesHistory[fileEntryIndex].fileName;

        // 1. Remove transactions from the main array
        const transactionsBefore = transactions.length;
        transactions = transactions.filter(t => t.fileName !== fileNameToDelete);
        const transactionsDeleted = transactionsBefore - transactions.length;
        
        // 2. Remove the file from history
        importedFilesHistory.splice(fileEntryIndex, 1);
        
        // 3. Re-render UI
        renderImportsHistory();
        applyDateFilter(); // Re-filters and re-renders transactions/totals
        applyBreakdownFilter(); // Re-calculates category breakdown
        
        alert(`Successfully deleted ${transactionsDeleted} transactions from file: ${fileNameToDelete}`);
    }

    // --- Manual Transaction Modal Logic ---
    let currentManualTransactionData = {}; // Temp store for manual entry
    function resetManualModal() {
        document.getElementById('manualTransactionModal').dataset.context = 'add';
        document.querySelector('#manualTransactionModal h2').textContent = 'Add Manual Transaction';
        document.getElementById('manual-save-btn').textContent = 'Save Transaction';
        
        document.getElementById('manual-modal-action-buttons').innerHTML = `
            <button onclick="saveManualTransaction()" class="btn-full" id="manual-save-btn">Save Transaction</button>
            <button onclick="closeModal('manualTransactionModal')" class="btn-na">Cancel</button>
        `;
        
        document.getElementById('manual-date').value = new Date().toISOString().substring(0, 10);
        document.getElementById('manual-cc').value = 'Manual';
        document.getElementById('manual-desc').value = '';
        document.getElementById('manual-category').value = 'Uncategorized';
        document.getElementById('manual-original-amount').value = '';
        document.getElementById('manual-my-total').value = '';
        document.getElementById('manual-notes').value = '';
        
        // Reset split status to Full (defaulting to the first button)
        handleManualSplitAction('full');
    }
    function openEditTransactionModal(index = null) {
        resetManualModal(); // Always reset first

        if (index !== null) {
            editingTransactionIndex = index;
            const t = displayedTransactions[index];
            if (!t || t.fileName !== 'Manual Entry') return; // Only allow editing manual entries

            document.getElementById('manualTransactionModal').dataset.context = 'edit';
            document.querySelector('#manualTransactionModal h2').textContent = 'Edit Manual Transaction';
            document.getElementById('manual-save-btn').textContent = 'Update Transaction';

            document.getElementById('manual-date').value = new Date(t.dateObj).toISOString().substring(0, 10);
            document.getElementById('manual-cc').value = t.creditCard;
            document.getElementById('manual-desc').value = t.description;
            document.getElementById('manual-category').value = t.category;
            document.getElementById('manual-original-amount').value = t.originalAmount.toFixed(2);
            document.getElementById('manual-my-total').value = t.myTotal.toFixed(2);
            document.getElementById('manual-notes').value = t.notes;

            // Update split status buttons
            let statusAction = t.status.toLowerCase().replace(' split', ''); // Convert 'Custom Split' to 'custom'
            handleManualSplitAction(statusAction);

            // Add Delete button to modal footer
            document.getElementById('manual-modal-action-buttons').innerHTML = `
                <button onclick="saveManualTransaction()" class="btn-full" id="manual-save-btn" style="flex: 2;">Update Transaction</button>
                <button onclick="deleteTransaction(${index})" class="btn-delete" style="flex: 1;">Delete</button>
                <button onclick="closeModal('manualTransactionModal')" class="btn-na" style="flex: 1;">Cancel</button>
            `;
        }
        
        // Ensure dropdowns are current before showing the modal
        reRenderCategoryDropdowns('manual-category');
        openModal('manualTransactionModal');
    }
    function handleManualAmountChange() {
        const originalAmountInput = document.getElementById('manual-original-amount');
        const originalAmount = parseFloat(originalAmountInput.value || 0);
        const myTotalInput = document.getElementById('manual-my-total');
        
        const selectedAction = document.querySelector('#manual-split-buttons .action-button.applied');
        const status = selectedAction ? selectedAction.dataset.action : 'full'; // Default to full

        let myTotal;
        if (status === 'full') {
            myTotal = originalAmount;
        } else if (status === 'half') {
            myTotal = originalAmount / 2;
        } else if (status === 'na') {
            myTotal = 0;
        } else {
            // Keep current value if custom split is selected
            return;
        }
        myTotalInput.value = myTotal.toFixed(2);
    }
    // Helper to handle button selection logic
    function handleManualSplitAction(action) {
        document.querySelectorAll('#manual-split-buttons .action-button').forEach(btn => btn.classList.remove('applied'));
        const selectedBtn = document.querySelector(`#manual-split-buttons button[data-action="${action}"]`);
        if (selectedBtn) {
            selectedBtn.classList.add('applied');
        }
        
        const myTotalInput = document.getElementById('manual-my-total');
        // Disable My Total input if not custom split
        const disableMyTotal = (action !== 'custom');
        myTotalInput.disabled = disableMyTotal;

        // Recalculate if we switched to a non-custom, non-N/A action
        if (action === 'full' || action === 'half') {
            handleManualAmountChange();
        } else if (action === 'na') {
            myTotalInput.value = '0.00';
        }
    }
    function openManualCustomSplitModal() {
        // Simple alert/prompt or use the Custom Split modal logic if desired
        alert('For Custom Split, please enter the desired My Total amount below.');
        handleManualSplitAction('custom'); // Ensure the custom button is highlighted
        document.getElementById('manual-my-total').focus();
    }
    // If user manually edits myTotal, force the status to 'custom'
    function handleManualMyTotalInput() {
        const selectedAction = document.querySelector('#manual-split-buttons .action-button.applied');
        if (!selectedAction || selectedAction.dataset.action !== 'custom') {
            handleManualSplitAction('custom');
        }
    }
    function saveManualTransaction() {
        const dateInput = document.getElementById('manual-date');
        const ccInput = document.getElementById('manual-cc');
        const descInput = document.getElementById('manual-desc');
        const categoryInput = document.getElementById('manual-category');
        const originalAmountInput = document.getElementById('manual-original-amount');
        const myTotalInput = document.getElementById('manual-my-total');
        const notesInput = document.getElementById('manual-notes');
        
        const originalAmount = parseFloat(originalAmountInput.value);
        let myTotal = parseFloat(myTotalInput.value);
        const status = document.querySelector('#manual-split-buttons .action-button.applied').dataset.action;
        
        if (!dateInput.value || isNaN(originalAmount)) {
            alert('Please enter a valid Date and Original Amount.');
            return;
        }
        
        // Final sanity check for myTotal based on status
        if (status === 'na') {
            myTotal = 0;
        } else if (status === 'half') {
            myTotal = originalAmount / 2;
        } else if (status === 'full') {
            myTotal = originalAmount;
        } else if (isNaN(myTotal)) {
             myTotal = originalAmount / 2; // Default to half if custom split is selected but no value entered
        }
        
        const dateString = dateInput.value;
        const dateObj = parseDateInput(dateString);

        const newTransaction = {
            id: editingTransactionIndex !== null ? displayedTransactions[editingTransactionIndex].id : Date.now(),
            date: dateString,
            dateObj: dateObj,
            creditCard: ccInput.value || 'Manual',
            description: descInput.value || 'Manual Entry',
            category: categoryInput.value || 'Uncategorized',
            originalAmount: originalAmount,
            myTotal: myTotal,
            status: status === 'custom' ? 'Custom Split' : status.charAt(0).toUpperCase() + status.slice(1),
            fileName: 'Manual Entry', // Mark as manual
            notes: notesInput.value || ''
        };
        
        uniqueCategories.add(newTransaction.category);

        if (editingTransactionIndex !== null) {
            // Edit existing transaction (update both in full list and displayed list)
            const oldT = displayedTransactions[editingTransactionIndex];
            // Find the original index in the full 'transactions' array to ensure persistence
            const originalIndex = transactions.findIndex(t => t.date === oldT.date && t.description === oldT.description && t.originalAmount === oldT.originalAmount && t.fileName === oldT.fileName);
            
            Object.assign(oldT, newTransaction); // Update displayed
            if (originalIndex !== -1) {
                Object.assign(transactions[originalIndex], newTransaction); // Update full list
            }
        } else {
            // Add new transaction
            transactions.push(newTransaction);
            // Ensure the 'Manual Entry' file is added to history if it doesn't exist
            if (!importedFilesHistory.find(f => f.id === MANUAL_ENTRY_ID)) {
                importedFilesHistory.push({
                    id: MANUAL_ENTRY_ID,
                    fileName: 'Manual Entry',
                    creditCard: 'Manual',
                    transactionCount: 1,
                    dateAdded: new Date().toLocaleDateString()
                });
            } else {
                // Increment the count
                importedFilesHistory.find(f => f.id === MANUAL_ENTRY_ID).transactionCount++;
            }
        }

        closeModal('manualTransactionModal');
        // FIX: Recalculate totals and re-render with re-applied filters/sort
        applyDateFilter();
    }
    // NEW: Generalized delete function
    function deleteTransaction(index) {
        if (!confirm('Are you sure you want to delete this transaction? This action cannot be undone.')) return;

        // 1. Get the transaction object from the currently displayed list
        const t = displayedTransactions[index];

        // 2. Find the original index in the full 'transactions' array to ensure persistence
        const originalIndex = transactions.findIndex(origT => 
            origT.date === t.date && 
            origT.description === t.description && 
            origT.originalAmount === t.originalAmount && 
            origT.fileName === t.fileName 
        );

        if (originalIndex !== -1) {
            // 3. Remove from the main data array
            transactions.splice(originalIndex, 1);
        }
        
        // 4. If it was a manual entry, decrement the count in history
        if (t.fileName === 'Manual Entry') {
            const manualEntry = importedFilesHistory.find(f => f.id === MANUAL_ENTRY_ID);
            if (manualEntry) {
                manualEntry.transactionCount = Math.max(0, manualEntry.transactionCount - 1);
                // If the last manual entry is deleted, you might choose to remove the history entry entirely
                if (manualEntry.transactionCount === 0) {
                     const historyIndex = importedFilesHistory.indexOf(manualEntry);
                     importedFilesHistory.splice(historyIndex, 1);
                }
            }
        }

        // 5. Update UI
        closeModal('manualTransactionModal'); // Close modal in case we deleted from edit mode
        applyDateFilter(); // Re-filters and re-renders transactions/totals
        applyBreakdownFilter(); // Re-calculates category breakdown
        renderImportsHistory(); // Refresh imports list if it was a manual entry
    }

    // --- Category Management Functions ---
    function reRenderCategoryDropdowns(targetId = null) {
        const categoriesArray = Array.from(uniqueCategories).sort();
        const allCategories = ['Uncategorized', ...categoriesArray.filter(cat => cat !== 'Uncategorized')];
        
        const renderOptions = (selectedValue) => {
            return allCategories.map(cat => 
                `<option value="${cat}" ${cat === selectedValue ? 'selected' : ''}>${cat}</option>`
            ).join('');
        };

        // Update Manual Entry Modal dropdown
        if (targetId === 'manual-category') {
            const select = document.getElementById('manual-category');
            if (select) {
                const selectedValue = select.value;
                select.innerHTML = renderOptions(selectedValue);
            }
            return;
        }
        
        // Re-render all category selects in the table
        document.querySelectorAll('.category-select').forEach(select => {
            const selectedValue = select.value;
            select.innerHTML = renderOptions(selectedValue);
        });
    }
    function openNewCategoryModal() {
        document.getElementById('new-category-name-input').value = '';
        openModal('newCategoryModal');
    }
    function addNewCategory() {
        const newCatName = document.getElementById('new-category-name-input').value.trim();
        if (newCatName && !uniqueCategories.has(newCatName)) {
            uniqueCategories.add(newCatName);
            reRenderCategoryDropdowns();
            applyBreakdownFilter();
            closeModal('newCategoryModal');
        } else if (uniqueCategories.has(newCatName)) {
            alert('Category already exists.');
        } else {
            alert('Please enter a category name.');
        }
    }
    function openManageCategoryModal(category) {
        currentManagingCategory = category;
        document.getElementById('current-category-name-display').textContent = category;
        document.getElementById('new-category-name').value = category;
        openModal('manageCategoryModal');
    }
    function performRenameCategory() {
        const oldCat = currentManagingCategory;
        const newCat = document.getElementById('new-category-name').value.trim();

        if (!newCat || newCat === oldCat) {
            alert('Invalid or unchanged category name.');
            return;
        }

        if (uniqueCategories.has(newCat)) {
            alert(`Category "${newCat}" already exists. Cannot rename.`);
            return;
        }

        // 1. Update transactions
        transactions.forEach(t => {
            if (t.category === oldCat) {
                t.category = newCat;
            }
        });

        // 2. Update set
        uniqueCategories.delete(oldCat);
        uniqueCategories.add(newCat);

        // 3. Refresh UI
        reRenderCategoryDropdowns();
        applyBreakdownFilter(); // Recalculates and re-renders breakdown list
        renderTransactions(); // Re-renders transaction list with new dropdowns
        closeModal('manageCategoryModal');
    }
    function deleteCategory(categoryToDelete) {
        if (!confirm(`Are you sure you want to delete the category "${categoryToDelete}"? All transactions in this category will be moved to "Uncategorized". This action cannot be undone.`)) {
            return;
        }
        
        // 1. Re-categorize all affected transactions
        transactions.forEach(t => {
            if (t.category === categoryToDelete) {
                t.category = 'Uncategorized';
            }
        });

        // 2. Remove from the set
        uniqueCategories.delete(categoryToDelete);
        uniqueCategories.add('Uncategorized'); // Ensure Uncategorized exists

        // 3. Refresh UI
        reRenderCategoryDropdowns();
        applyBreakdownFilter(); 
        renderTransactions();
        closeModal('manageCategoryModal');
    }

    // --- Category Breakdown Functions ---
    function sortBreakdown(key) {
        const direction = breakdownSort.key === key && breakdownSort.direction === 'desc' ? 'asc' : 'desc';
        breakdownSort = { key, direction };
        renderBreakdownList();
    }
    function applyBreakdownFilter() {
        const preset = document.getElementById('breakdown-date-range-preset').value;
        let startDate = null;
        let endDate = null;
        const now = new Date();

        if (preset === 'current_month') {
            startDate = new Date(now.getFullYear(), now.getMonth(), 1);
            endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
        } else if (preset === 'last_month') {
            startDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
            endDate = new Date(now.getFullYear(), now.getMonth(), 0);
        } else if (preset === 'all_time') {
            // Handled below by null check
        }
        
        // Add one day to the end date to make it inclusive until the end of that day
        if (endDate) {
            endDate = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate() + 1);
            endDate.setSeconds(endDate.getSeconds() - 1); // Set to 23:59:59
        }

        // Define a single category to exclude from the total calculation for percentages
        const EXCLUDED_FOR_CALC = 'my payments';

        // Filter transactions based on date range
        const filteredTxns = transactions.filter(t => {
            const date = t.dateObj;
            if (!date) return false;
            const meetsStart = !startDate || date >= startDate;
            const meetsEnd = !endDate || date <= endDate;
            return meetsStart && meetsEnd;
        });

        const breakdown = {};
        let totalOriginalAmountForCalc = 0; // NEW: Total for calculating percentages (excludes 'my payments')
        let totalMyShareForCalc = 0; // NEW: Total for calculating grand total in footer (excludes 'my payments')

        filteredTxns.forEach(t => {
            const cat = t.category || 'Uncategorized';
            const isExcluded = cat.toLowerCase() === EXCLUDED_FOR_CALC;

            if (!breakdown[cat]) {
                breakdown[cat] = { 
                    category: cat, 
                    count: 0, 
                    originalAmount: 0, 
                    myTotal: 0, 
                    isExcluded: isExcluded // Mark for later rendering
                };
            }
            breakdown[cat].count++;
            breakdown[cat].originalAmount += t.originalAmount;
            breakdown[cat].myTotal += t.myTotal;

            // Only include in the calculation totals if NOT the excluded category
            if (!isExcluded) {
                totalOriginalAmountForCalc += t.originalAmount;
                totalMyShareForCalc += t.myTotal;
            }
        });

        // Convert to array and calculate percentages based on totalOriginalAmountForCalc
        currentBreakdownData = Object.values(breakdown).map(item => {
            let percentage = 0;
            if (!item.isExcluded && totalOriginalAmountForCalc !== 0) {
                percentage = (item.originalAmount / totalOriginalAmountForCalc) * 100;
            }
            
            // NEW: For the excluded category, force amounts and percentage to 0 for display
            const displayOriginalAmount = item.isExcluded ? 0 : item.originalAmount;
            const displayMyTotal = item.isExcluded ? 0 : item.myTotal;

            return {
                ...item,
                percentage: percentage,
                displayOriginalAmount: displayOriginalAmount, // Used for display
                displayMyTotal: displayMyTotal // Used for display
            };
        });

        renderBreakdownList(totalOriginalAmountForCalc, totalMyShareForCalc);
    }
    function renderBreakdownList(grandTotalOriginal, grandTotalMyShare) {
        // Sort the data first
        const key = breakdownSort.key;
        const direction = breakdownSort.direction === 'asc' ? 1 : -1;

        currentBreakdownData.sort((a, b) => {
            let comparison = 0;
            if (typeof a[key] === 'number' && typeof b[key] === 'number') {
                comparison = a[key] - b[key];
            } else {
                comparison = String(a[key]).localeCompare(String(b[key]));
            }
            return comparison * direction;
        });

        updateSortIndicators('category-breakdown-list', breakdownSort);

        // Pass the grand totals before rendering (these totals are derived *before* sorting/filtering)
        renderBreakdown(grandTotalOriginal, grandTotalMyShare);
    }
    function renderBreakdown(totalOriginalAmount, totalMyShare) {
        const tbody = document.getElementById('breakdown-body');
        const tfoot = document.getElementById('breakdown-footer');
        tbody.innerHTML = '';
        tfoot.innerHTML = '';

        if (currentBreakdownData.length === 0) {
            tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #666; padding: 20px;">No transactions found for the selected range.</td></tr>';
            return;
        }

        currentBreakdownData.forEach(item => {
            const row = tbody.insertRow();
            row.insertCell().textContent = item.category;
            row.insertCell().textContent = item.count;
            
            // Conditional display based on the isExcluded flag
            if (item.isExcluded) {
                row.insertCell().textContent = ''; // Percentages N/A for excluded category
            } else {
                row.insertCell().textContent = item.percentage.toFixed(2) + '%';
            }

            row.insertCell().textContent = formatCurrency(item.displayOriginalAmount);
            row.insertCell().textContent = formatCurrency(item.displayMyTotal);
            
            const actionsCell = row.insertCell();
            if (item.category !== 'Uncategorized') {
                actionsCell.innerHTML = `<button onclick="openManageCategoryModal('${item.category}')">Manage</button>`;
            }
        });

        // Render Footer
        const footerRow = tfoot.insertRow();
        footerRow.innerHTML = `
            <td style="font-weight: bold;">TOTAL:</td>
            <td style="font-weight: bold;">${currentBreakdownData.reduce((sum, item) => sum + item.count, 0)}</td>
            <td style="font-weight: bold;">100%</td>
            <td style="font-weight: bold;">${formatCurrency(totalOriginalAmount)}</td>
            <td style="font-weight: bold;">${formatCurrency(totalMyShare)}</td>
            <td></td>
        `;
    }

    // --- Export Function ---
    function exportToCSV() {
        if (transactions.length === 0) {
            alert("No transactions to export.");
            return;
        }

        const todayStr = new Date().toISOString().substring(0, 10);
        const csvRows = [];
        const headers = ['Date', 'Credit Card', 'Description', 'Category', 'Original Amount', 'My Total', 'Split Status', 'File Name', 'Notes'];
        csvRows.push(headers.join(','));

        const clean = (str) => {
            if (!str) return '';
            str = String(str).replace(/"/g, '""'); // Escape double quotes
            if (str.includes(',') || str.includes('\n')) {
                return `"${str}"`; // Enclose in quotes if it contains comma or newline
            }
            return str;
        };

        // Use the main transactions list for export, not the filtered one
        transactions.forEach(t => {
            const row = [
                clean(t.date),
                clean(t.creditCard),
                clean(t.description),
                clean(t.category),
                t.originalAmount.toFixed(2), 
                t.myTotal.toFixed(2),
                clean(t.status),
                clean(t.fileName),
                clean(t.notes)
            ];
            csvRows.push(row.join(','));
        });

        const csvString = csvRows.join('\n');
        const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");

        if (link.download !== undefined) { 
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            // MODIFIED: Use the local date string
            link.setAttribute("download", "transaction_export_" + todayStr + ".csv"); 
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } else {
            alert("Your browser does not support downloading files directly. Please copy the data manually.");
        }
    }

    // --- NEW CHECKLIST FUNCTIONS ---
    function loadChecklistState() {
        const storedState = localStorage.getItem(CHECKLIST_STORAGE_KEY);
        // Initialize state, prioritizing stored state if present
        CHECKLIST_ITEMS.forEach(item => {
            checklistState[item] = false; // Default to unchecked
        });
        if (storedState) {
            // Merge stored state back into the new item list, ignoring old/non-existent items
            const parsedState = JSON.parse(storedState);
            Object.keys(parsedState).forEach(key => {
                if (key in checklistState) {
                    checklistState[key] = parsedState[key];
                }
            });
        }
        renderChecklist();
    }

    function saveChecklistState() {
        localStorage.setItem(CHECKLIST_STORAGE_KEY, JSON.stringify(checklistState));
    }

    function renderChecklist() {
        const container = document.getElementById('checklist-container');
        if (!container) return; // Exit if tab isn't loaded/visible yet

        container.innerHTML = ''; // Clear existing list

        CHECKLIST_ITEMS.forEach(item => {
            const isChecked = checklistState[item] || false; 
            
            const itemDiv = document.createElement('div');
            itemDiv.className = `checklist-item ${isChecked ? 'checked' : ''}`;
            itemDiv.onclick = () => toggleChecklistItem(item);

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = isChecked;
            checkbox.onclick = (e) => e.stopPropagation(); // Prevent dual trigger from div click

            const label = document.createElement('label');
            label.textContent = item;
            
            itemDiv.appendChild(checkbox);
            itemDiv.appendChild(label);
            container.appendChild(itemDiv);
        });
    }

    function toggleChecklistItem(item) {
        checklistState[item] = !checklistState[item];
        saveChecklistState();
        renderChecklist(); // Re-render to update classes/styles
    }

    function clearCompletedChecklist() {
        // Find the button and change its text during the confirmation for clarity
        const button = document.querySelector('#checklist-tab .btn-delete');
        const originalText = button.textContent;
        button.textContent = 'Clearing...';

        if (!confirm("Are you sure you want to uncheck all items in the checklist?")) {
            button.textContent = originalText;
            return;
        }

        CHECKLIST_ITEMS.forEach(item => {
            checklistState[item] = false;
        });
        
        saveChecklistState();
        renderChecklist();
        button.textContent = originalText;
    }
    // --- END NEW CHECKLIST FUNCTIONS ---

    
    // Initial call to set filters and render if data exists (for persistence)
    document.addEventListener('DOMContentLoaded', () => {
         applyDateFilter(); 
         applyBreakdownFilter(); 
         // Optional: load checklist state on startup if we wanted to display a count on the tab, 
         // but for now, loadChecklistState() is called when the tab is opened.
    });
</script>

</body>
</html>
