<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transaction Splitter</title>
    <style>
        /* Styling to match Period Tracker V2_13.html */
        *, *::before, *::after {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
              Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif; /* Period App Font */
            margin: 0; 
            padding: 0; 
            background-color: #ffffff; /* Period App Body Background */
            color: #333;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .container {
            /* CHANGES FOR WIDER DESKTOP USE: */
            max-width: none; 
            width: 98%; 
            min-width: 600px; 
            margin: 20px auto;
            /* END CHANGES */

            background-color: #fff;
            padding: 20px;
            border-radius: 8px; 
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); 
            border: 1px solid #cce5ff; 
        }
        h1 {
            /* Style to match the look of the Period App's h2 and header */
            color: #2473BC; 
            border-bottom: 2px solid #76AFE5; 
            padding-bottom: 4px;
            margin-bottom: 1.5rem;
            font-size: 50px; 
            text-align: center;
            font-weight: 700;
        }
        /* --- New #total-container styles for prominence --- */
        #total-container {
            background-color: #eaf3fb; 
            border: 1px solid #cce5ff; 
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 6px; 
            
            display: grid;
            grid-template-columns: 1fr 1fr;
            text-align: center;
            font-weight: 600;
        }
        .total-box {
            display: flex;
            flex-direction: column;
            padding: 10px;
        }
        .total-box.my-share {
            color: #2473BC; /* My Share is primary blue */
            border-right: 1px solid #cce5ff; /* Separator line */
        }
        .total-box.full-total {
            color: #333;
        }
        .total-amount {
            font-size: 2.5em; /* Bigger font for amount */
            font-weight: 700;
            line-height: 1.1;
        }
        .total-label {
            font-size: 0.9em;
            margin-top: 5px;
            color: #666; /* Gray out the label slightly */
        }
        .total-box.my-share .total-label {
            color: #2473BC;
        }
        /* ----------------------------------------------------------------- */
        
        /* --- Import/Export Controls Layout (50/50 Split) --- */
        .controls-wrapper {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px; 
            margin-bottom: 20px;
        }

        /* Removed blue box frame for import/export containers */
        #import-controls-container {
            display: flex; 
            flex-direction: column;
            gap: 10px; 
            padding: 0; 
            border: none; 
            background-color: transparent; 
            border-radius: 6px; 
        }
        
        /* Removed blue box frame for import/export containers */
        #export-frame {
            display: flex;
            flex-direction: column;
            justify-content: center; 
            padding: 0; 
            border: none;
            background-color: transparent;
            border-radius: 6px; 
        }
        
        .import-action-button {
            padding: 12px 20px;
            font-size: 1.1rem;
            background-color: #2473BC;
            color: white;
            width: 100%;
        }

        /* UPDATED STYLING FOR EXPORT BUTTON (Light Blue) */
        #export-frame button {
            padding: 12px 20px;
            font-size: 1.1rem;
            background-color: #CDE6F8; /* Light Blue Background */
            color: #2473BC; /* Primary Blue Text */
            border: 2px solid #76AFE5; /* Border to match the frame */
            width: 100%; 
            height: 100%; 
            margin: 0;
            display: block;
            font-weight: 700;
        }

        /* Hide the actual file input */
        #csv-file-input {
            display: none; 
        }

        /* --- Tab Styling --- */
        .tabs {
            display: flex;
            border-bottom: 2px solid #76AFE5;
            margin-bottom: 20px;
        }
        .tab-button {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            background-color: #f8fbfe;
            color: #2473BC;
            font-weight: 600;
            transition: all 0.2s;
        }
        .tab-button.active {
            border-color: #76AFE5;
            border-bottom: 2px solid white; 
            background-color: white;
            color: #2473BC;
            margin-bottom: -2px; 
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        
        /* --- NEW STYLES FOR TRANSACTION HEADER CONTROLS (Filters + Add Button) --- */
        .transactions-header-controls {
            display: flex; 
            justify-content: space-between; /* Push button to the right */
            align-items: center; /* Vertically align items */
            margin-bottom: 20px;
            gap: 20px; /* Space between filter section and button */
        }

        /* Style the filter section for existing elements */
        #filter-presets {
            display: flex;
            align-items: center;
            gap: 10px; /* Space between filter elements */
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }
        
        /* Style the new button to match the size of a select/input */
        #add-transaction-btn {
            padding: 10px 20px; /* Similar to select padding */
            font-size: 0.95rem; /* Similar to select font size */
            background-color: #2473BC; /* Primary blue color */
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            /* FIX: Ensure width is determined by content only and it doesn't grow */
            width: auto; 
            flex-grow: 0; 
        }
        
        #category-controls {
            display: flex; 
            gap: 10px;
        }
        
        #add-category-btn {
            padding: 10px 15px; 
            font-size: 0.95rem; 
            background-color: #CDE6F8; 
            color: #2473BC; 
            border: 1px solid #76AFE5; 
            border-radius: 6px; 
            font-weight: 600;
            width: auto; 
            flex-grow: 0; 
        }
        /* --- END NEW STYLES --- */


        /* --- Table Styling and Sorting --- */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: left;
            vertical-align: middle; 
        }
        th {
            background-color: #79AFDE; 
            color: white;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        /* Clickable headers */
        th.sortable {
            cursor: pointer;
            position: relative;
        }
        th.sortable::after {
            content: '';
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            border: 4px solid transparent;
            opacity: 0.5;
        }
        th.sortable.asc::after {
            content: '▲';
            opacity: 1;
            font-size: 0.7em;
            right: 5px;
        }
        th.sortable.desc::after {
            content: '▼';
            opacity: 1;
            font-size: 0.7em;
            right: 5px;
        }

        tr:nth-child(even) {
            background-color: #f8fbfe; 
        }

        /* Gray-out style for N/A rows */
        .na-applied td {
            color: #989898; 
            font-style: italic;
        }
        
        .notes-input {
            width: 100%;
            padding: 4px 6px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 0.85rem;
        }

        /* --- Buttons and Modals --- */
        .action-buttons-grid, .import-actions-grid {
            display: grid;
            /* MODIFIED: Change to 3 columns for 4 split buttons + 1 edit + 1 delete = 6 items per row */
            grid-template-columns: 1fr 1fr 1fr; 
            gap: 5px;
            width: 100%;
        }
        
        /* NEW: Full width for manual entry actions (1 button only now) */
        .action-buttons-grid.single-button {
             grid-template-columns: 1fr;
        }

        .import-actions-grid {
            grid-template-columns: 1fr 1fr; 
        }
        .cc-buttons-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        .cc-buttons-grid button {
            width: 100%;
            font-size: 1rem;
            padding: 12px 5px;
            background-color: #79AFDE;
            color: white;
            border: none;
        }
        
        button {
            padding: 8px 5px; 
            margin: 0; 
            width: 100%; 
            cursor: pointer;
            border: none;
            border-radius: 6px; 
            font-weight: 600; 
            transition: all 0.2s;
            font-size: 0.9rem; 
            box-sizing: border-box; 
        }

        .btn-full, .btn-split-half, .btn-split-custom, .btn-change-cc { 
            background-color: #79AFDE; 
            color: white; 
        } 
        .btn-na { 
            background-color: #989898; 
            color: white;
        }
        .btn-delete { background-color: #e66666; }

        /* Default state: all buttons are outlines */
        .action-button {
            background-color: transparent !important;
            border: 2px solid #79AFDE; 
            color: #2473BC !important; 
            font-weight: 600;
            padding: 6px 5px; 
        }
        .btn-na.action-button { 
            border-color: #989898; 
            color: #989898 !important;
        }
        
        /* Button for editing manual entries */
        .btn-edit-manual {
            background-color: #CDE6F8 !important; 
            border: 2px solid #76AFE5; 
            color: #2473BC !important;
        }

        /* Action Applied State (Turns into a solid-filled button) */
        .btn-full.applied, .btn-split-half.applied, .btn-split-custom.applied { 
            background-color: #79AFDE !important; 
            color: white !important; 
            border: none;
        }
        
        /* OVERRIDE: Set Full button to the main blue color (#2473BC) when applied */
        .btn-full.applied {
            background-color: #2473BC !important; 
            color: white !important; 
            border: none !important;
        }

        .btn-na.applied { 
            background-color: #989898 !important; 
            color: white !important; 
            border: none;
        }


        .negative { color: black; } 
        .positive { color: green; } 

        select, input[type="number"], input[type="text"], input[type="date"] {
            padding: 8px 10px;
            border-radius: 6px;
            border: 1px solid #cce5ff; 
            margin-right: 10px;
            box-sizing: border-box;
            font-size: 0.95rem;
            min-width: 150px; 
        }

        /* Target all select elements in the table for a small padding */
        .category-select {
            width: 100%;
            padding: 6px 8px; 
            font-size: 0.85rem;
        }
        
        /* --- Modal Styling Updates --- */
        .modal {
            display: none; 
            position: fixed; 
            z-index: 100; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.4); 
        }
        .modal-content {
            background-color: #fefefe;
            margin: 10% auto; 
            padding: 25px;
            border: 1px solid #76AFE5; 
            width: 90%; 
            max-width: 500px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(36, 115, 188, 0.2); 
            position: relative; /* REQUIRED for close-btn positioning */
        }
        
        /* Custom Split Modal Row Spacing */
        .modal-details div, 
        .modal-field {
            margin-bottom: 10px; 
        }
        
        /* Styling for the manual transaction form fields */
        #manualTransactionModal .modal-field {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #manualTransactionModal .modal-field label {
            font-weight: 600;
            font-size: 0.9em;
            color: #333;
        }
        #manualTransactionModal .modal-field input, 
        #manualTransactionModal .modal-field select {
            min-width: 100%;
            box-sizing: border-box;
            margin: 0;
        }
        
        /* Make the modal button row three columns when editing (Save, Delete, Cancel) */
        #manualTransactionModal .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        #manualTransactionModal .modal-buttons button {
            flex: 1;
	        margin-top: 20px;
        }
        
        /* Ensure split buttons in modal don't stretch vertically */
        #manual-split-buttons button {
            height: auto; 
            padding: 6px 5px;
        }


        /* Close button positioning */
        .close-btn {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            position: absolute; 
            top: 10px; 
            right: 15px; 
            cursor: pointer;
            line-height: 1; 
            padding: 0;
            margin: 0;
            background: none; 
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Transaction Splitter</h1>

    <div class="controls-wrapper">
        
        <div id="import-controls-container">
            <button class="import-action-button" onclick="triggerFileUpload('new')">Import Transactions</button>
            <button class="import-action-button" onclick="triggerFileUpload('old')">Import Old Data</button>
        </div>

        <div id="export-frame">
            <button onclick="exportToCSV()">Export All Data to CSV</button>
        </div>
        
        <input type="file" id="csv-file-input" accept=".csv" multiple>
    </div>

    <div class="tabs">
        <button class="tab-button active" onclick="openTab('transactions-tab', this)">Transactions</button>
        <button class="tab-button" onclick="openTab('imports-tab', this)">File Imports</button>
        <button class="tab-button" onclick="openTab('category-breakdown-tab', this)">Category Breakdown</button>
    </div>

    <div id="transactions-tab" class="tab-content active">
        <div id="total-container">
            <div class="total-box my-share">
                <span id="full-my-total" class="total-amount">$0.00</span>
                <span class="total-label">My Share</span>
            </div>
            <div class="total-box full-total">
                <span id="full-original-total" class="total-amount">$0.00</span>
                <span class="total-label">Full Total Amount</span>
            </div>
        </div>
        <div id="filter-controls" class="transactions-header-controls">
            <div id="filter-presets">
                <label for="date-range-preset">View Range:</label>
                <select id="date-range-preset" onchange="applyDateFilter()">
                    <option value="current_month">This Month</option>
                    <option value="last_month">Last Month</option>
                    <option value="all_time" selected>All Time</option>
                    <option value="custom">Custom Range</option>
                </select>

                <div id="custom-date-range" style="display: none;">
                    <label for="start-date">Start Date:</label>
                    <input type="date" id="start-date" onchange="applyDateFilter()">
                    
                    <label for="end-date">End Date:</label>
                    <input type="date" id="end-date" onchange="applyDateFilter()">
                </div>
            </div>
            <div id="category-controls">
                <button id="add-transaction-btn" onclick="openEditTransactionModal()">Add Manual Transaction</button>
                <button id="add-category-btn" onclick="openNewCategoryModal()">Add Category</button>
            </div>
        </div>
        <div id="transactions-list">
            <table>
                <thead>
                    <tr>
                        <th style="width: 8%;" class="sortable" data-sort-key="dateObj" onclick="sortTransactions('dateObj')">Date</th>
                        <th style="width: 10%;">Credit Card</th>
                        <th style="width: 20%;">Description</th>
                        <th style="width: 10%;">Category</th>
                        <th style="width: 8%;">Original Amount</th>
                        <th style="width: 8%;">My Total</th>
                        <th style="width: 16%;">Actions</th>
                        <th style="width: 20%;">Notes</th>
                    </tr>
                </thead>
                <tbody id="transactions-body">
                    </tbody>
            </table>
        </div>
    </div>

    <div id="imports-tab" class="tab-content">
        <h2>Imported Files History</h2>
        <div id="imports-list">
            <table>
                <thead>
                    <tr>
                        <th style="width: 40%;">File Name</th>
                        <th style="width: 25%;">Credit Card</th>
                        <th style="width: 15%;">Transactions</th>
                        <th style="width: 20%;">Actions</th>
                    </tr>
                </thead>
                <tbody id="imports-body">
                </tbody>
            </table>
        </div>
    </div>

    <div id="category-breakdown-tab" class="tab-content">
        <h2>Category Breakdown</h2>
        <div id="breakdown-filter-controls">
            <label for="breakdown-date-range-preset">View Range:</label>
            <select id="breakdown-date-range-preset" onchange="applyBreakdownFilter()">
                <option value="current_month">This Month</option>
                <option value="last_month">Last Month</option>
                <option value="all_time" selected>All Time</option>
            </select>
        </div>
        <div id="category-breakdown-list">
            <table>
                <thead>
                    <tr>
                        <th style="width: 20%;">Category</th>
                        <th style="width: 15%;">Transaction Count</th>
                        <th style="width: 15%;" class="sortable" data-sort-key="percentage" onclick="sortBreakdown('percentage')">Percentages</th>
                        <th style="width: 20%;">Total Original Amount</th>
                        <th style="width: 15%;">Total My Share</th>
                        <th style="width: 15%;">Actions</th> </tr>
                </thead>
                <tbody id="breakdown-body">
                    <tr><td colspan="6" style="text-align: center; color: #666; padding: 20px;">Load transactions to see breakdown.</td></tr>
                </tbody>
                <tfoot id="breakdown-footer"></tfoot>
            </table>
        </div>
    </div>
</div>

<div id="creditCardSelectModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('creditCardSelectModal')">&times;</span>
        <h2 id="cc-modal-title">Select Credit Card for Imported File</h2>
        <p>Please choose which credit card these transactions are from:</p>
        <div id="cc-buttons-container" class="cc-buttons-grid">
            </div>
    </div>
</div>

<div id="changeCCModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('changeCCModal')">&times;</span>
        <h2 id="reassign-cc-title">Reassign Credit Card</h2>
        <p>Select a new card for: <strong id="reassign-file-name"></strong></p>
        <div id="reassign-buttons-container" class="cc-buttons-grid">
            </div>
    </div>
</div>

<div id="customSplitModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('customSplitModal')">&times;</span>
        <h2>Custom Split: Set My Total</h2>

        <div class="modal-details">
            <div><strong>Date:</strong> <span id="modal-date"></span></div>
            <div><strong>Description:</strong> <span id="modal-description"></span></div>
            <div><strong>Category:</strong> <span id="modal-category"></span></div>
            <div><strong>Original Amount:</strong> <span id="modal-original-amount" style="font-weight: bold;">$0.00</span></div>
        </div>

        <div class="modal-field">
            <label style="font-weight: 600;">Transaction Type:</label>
            <div style="display: flex; gap: 20px;">
                <label><input type="radio" name="custom-type" value="transaction" checked> Transaction (Expense)</label>
                <label><input type="radio" name="custom-type" value="refund"> Refund (Credit)</label>
            </div>
        </div>
        
        <div class="modal-field">
            <label for="custom-amount-input" style="font-weight: 600;">Amount to Assign to My Total (Positive Number Only):</label>
            <input type="number" id="custom-amount-input" placeholder="e.g., 55.75" step="0.01" min="0">
        </div>

        <div class="modal-buttons">
            <button onclick="applyCustomSplit()" class="btn-full" style="margin-bottom: 10px; margin-top:25px;">Apply Custom Amount</button>
            <button onclick="closeModal('customSplitModal')" class="btn-na">Cancel</button>
        </div>
    </div>
</div>
<div id="manualTransactionModal" class="modal" data-context="add">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('manualTransactionModal')">&times;</span>
        <h2>Add Manual Transaction</h2>
        
        <div class="modal-field">
            <label for="manual-date">Date <span style="color: red;">*</span></label>
            <input type="date" id="manual-date" required>
        </div>

        <div class="modal-field">
            <label for="manual-cc">Credit Card</label>
            <select id="manual-cc"></select>
        </div>
        
        <div class="modal-field">
            <label for="manual-desc">Description</label>
            <input type="text" id="manual-desc">
        </div>
        
        <div class="modal-field">
            <label for="manual-category">Category</label>
            <select id="manual-category" class="category-select"></select>
        </div>

        <div class="modal-field">
            <label for="manual-original-amount">Original Amount ($) <span style="color: red;">*</span></label>
            <input type="number" id="manual-original-amount" step="0.01" placeholder="e.g., -55.75" required oninput="handleManualAmountChange()">
            <small style="color: #666; margin-top: -5px;">Put minus if a transaction is a charge (e.g., -55.75).</small>
        </div>
        
        <div class="modal-field">
            <label>Split Status</label>
            <div id="manual-split-buttons" class="action-buttons-grid">
                <button class="btn-split-half action-button" data-action="half" onclick="handleManualSplitAction('half')">Half</button>
                <button class="btn-full action-button" data-action="full" onclick="handleManualSplitAction('full')">Full</button>
                <button class="btn-split-custom action-button" data-action="custom" onclick="openManualCustomSplitModal()">Custom Split</button>
                <button class="btn-na action-button" data-action="na" onclick="handleManualSplitAction('na')">N/A</button>
            </div>
        </div>
        
        <div class="modal-field">
            <label for="manual-my-total">My Total ($)</label>
            <input type="number" id="manual-my-total" step="0.01" placeholder="e.g., -27.88" oninput="handleManualMyTotalInput()">
        </div>
        
        <div class="modal-field">
            <label for="manual-notes">Notes</label>
            <input type="text" id="manual-notes">
        </div>

        <div class="modal-buttons" id="manual-modal-action-buttons">
            <button onclick="saveManualTransaction()" class="btn-full" id="manual-save-btn">Save Transaction</button>
            <button onclick="closeModal('manualTransactionModal')" class="btn-na">Cancel</button>
        </div>
    </div>
</div>

<div id="newCategoryModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('newCategoryModal')">&times;</span>
        <h2>Add New Category</h2>
        
        <div class="modal-field">
            <label for="new-category-name-input" style="font-weight: 600;">Category Name:</label>
            <input type="text" id="new-category-name-input" placeholder="e.g., Groceries" required>
        </div>

        <div class="modal-buttons" style="margin-top: 20px;">
            <button onclick="addNewCategory()" class="btn-full" style="background-color: #2473BC; margin-bottom: 10px; margin-top:25px;">Add Category</button>
            <button onclick="closeModal('newCategoryModal')" class="btn-na">Cancel</button>
        </div>
    </div>
</div>
<div id="manageCategoryModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('manageCategoryModal')">&times;</span>
        <h2>Manage Category: <strong id="current-category-name-display"></strong></h2>
        
        <p style="font-weight: bold; margin-top: 10px;">Rename Category</p>
        <div class="modal-field">
            <label for="new-category-name">New Name:</label>
            <input type="text" id="new-category-name" placeholder="Enter new category name">
        </div>
        
        <div class="modal-buttons" style="margin-bottom: 25px;">
            <button onclick="performRenameCategory()" class="btn-full" id="rename-category-btn" style="background-color: #2473BC;">Rename Category</button>
        </div>
        
        <hr style="border-top: 1px solid #cce5ff; margin: 15px 0;">
        
        <p style="font-weight: bold; color: #e66666; margin-bottom: 10px;">Danger Zone: Delete Category</p>
        <div class="modal-buttons">
            <button onclick="deleteCategory(currentManagingCategory)" class="btn-delete">Delete & Re-categorize to 'Uncategorized'</button>
        </div>
        <small style="color: #989898; margin-top: 5px; display: block;">This action cannot be undone.</small>

        <div class="modal-buttons" style="margin-top: 20px;">
            <button onclick="closeModal('manageCategoryModal')" class="btn-na">Close</button>
        </div>
    </div>
</div>
<script>
    // Global Constants
    const CREDIT_CARD_OPTIONS = [
        'Unlimited 3993', 
        'Sapphire 8906', 
        'Target', 
        'My CC',
        'Manual' // Added 'Manual' as a default CC option for manual entries
    ];
    // FIX: Define the missing constant used in parseCSV to exclude categories
    const EXCLUDED_CATEGORIES = ["credit card payments", "transfers"];
    // Special value to signal that card selection was skipped and to look in CSV
    const SKIP_CC_SELECTION = 'OLD_DATA_AUTO_ASSIGN'; 
    
    // Special ID for manual entries, which are now hidden from the imports list
    const MANUAL_ENTRY_ID = 0; 
    
    // Global variables
    let transactions = []; 
    let displayedTransactions = []; 
    let uniqueCategories = new Set();
    let fullOriginalTotal = 0;
    let fullMyTotal = 0;
    let currentTransactionIndex = null; 
    let editingTransactionIndex = null; 
    let currentManagingCategory = null; 
    
    // Sorting State
    let transactionSort = { key: 'dateObj', direction: 'asc' }; 
    let breakdownSort = { key: 'percentage', direction: 'desc' };
    
    // Data structures for file management
    let filesToProcess = []; 
    let currentProcessingFile = null; 
    let importedFilesHistory = []; 
    let reassigningFileIndex = null; 
    let currentImportType = 'new'; // 'new' or 'old'
    let currentBreakdownData = []; // To hold the category data for sorting

    // Event listener for the actual file input (now hidden)
    document.getElementById('csv-file-input').addEventListener('change', initializeFileUpload);
    document.getElementById('date-range-preset').addEventListener('change', applyDateFilter);
    document.getElementById('breakdown-date-range-preset').addEventListener('change', applyBreakdownFilter);

    // Initial setup of CC buttons in the two modals AND the CC dropdown in manual entry modal
    (function setupCCButtons() {
        const container = document.getElementById('cc-buttons-container');
        const reassignContainer = document.getElementById('reassign-buttons-container');
        const manualCCSelect = document.getElementById('manual-cc');
        
        CREDIT_CARD_OPTIONS.forEach(cardName => {
            // Initial Import Modal Buttons
            const btn1 = document.createElement('button');
            btn1.textContent = cardName;
            btn1.onclick = () => handleCreditCardSelection(cardName);
            container.appendChild(btn1);

            // Reassign CC Modal Buttons
            const btn2 = document.createElement('button');
            btn2.textContent = cardName;
            btn2.onclick = () => reassignCreditCard(reassigningFileIndex, cardName);
            reassignContainer.appendChild(btn2);
            
            // Manual Entry CC Dropdown Options
            const option = document.createElement('option');
            option.value = cardName;
            option.textContent = cardName;
            manualCCSelect.appendChild(option);
        });
        // Default the manual entry dropdown to the last option ('Manual') or first option
        manualCCSelect.value = 'Manual'; 
    })();
    
    // --- Utility Functions ---
    
    // Helper function to parse date strings and prevent timezone issues
    function parseDateInput(dateString) {
        // Appends T12:00:00 to treat the date as noon local time, mitigating timezone shifts
        if (!dateString) return null;
        // Check for common formats and handle them, but mostly rely on T12:00:00
        const datePart = dateString.split('T')[0];
        
        // This attempts to parse the date as a date string plus a time offset 
        // to prevent it from being interpreted as UTC midnight (which shifts the day).
        let date = new Date(datePart + 'T12:00:00');
        
        // Fallback for non-standard formats that the above logic might fail, but still need the local fix.
        // This is important for re-importing old, formatted dates.
        if (isNaN(date.getTime())) {
            date = new Date(dateString + 'T12:00:00');
        }

        // Final fallback on the raw string for very ambiguous formats
        if (isNaN(date.getTime())) {
            date = new Date(dateString);
        }
        
        return isNaN(date.getTime()) ? null : date;
    }
    
    function formatDate(dateString) {
        const date = parseDateInput(dateString); // Use parseDateInput to get a valid date
        if (date === null) return dateString; // Return original string if unparsable
        const options = { year: 'numeric', month: 'short', day: 'numeric' };
        return date.toLocaleDateString('en-US', options);
    }
    
    function formatCurrency(amount) {
        return new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: 'USD'
        }).format(amount);
    }
    
    function updateTotalsDisplay() {
        document.getElementById('full-original-total').textContent = formatCurrency(fullOriginalTotal);
        document.getElementById('full-my-total').textContent = formatCurrency(fullMyTotal);
    }
    
    function closeModal(id) {
        document.getElementById(id).style.display = 'none';
        if (id === 'customSplitModal') {
            currentTransactionIndex = null;
        } else if (id === 'manualTransactionModal') {
            editingTransactionIndex = null;
        }
    }
    
    function openModal(id) {
        document.getElementById(id).style.display = 'block';
    }

    window.onclick = function(event) {
        const customSplitModal = document.getElementById('customSplitModal');
        const ccSelectModal = document.getElementById('creditCardSelectModal');
        const changeCCModal = document.getElementById('changeCCModal');
        const manualTxnModal = document.getElementById('manualTransactionModal');
        const manageCatModal = document.getElementById('manageCategoryModal');
        const newCatModal = document.getElementById('newCategoryModal'); 
        
        if (event.target == customSplitModal) {
            closeModal('customSplitModal');
        } else if (event.target == ccSelectModal) {
            closeModal('creditCardSelectModal');
        } else if (event.target == changeCCModal) {
             closeModal('changeCCModal');
        } else if (event.target == manualTxnModal) {
             closeModal('manualTransactionModal');
        } else if (event.target == manageCatModal) {
             closeModal('manageCategoryModal');
        } else if (event.target == newCatModal) { 
             closeModal('newCategoryModal');
        }
    }

    // NEW FUNCTION: Calculates totals based on currently filtered/displayed transactions
    function calculateTotals() {
        fullOriginalTotal = 0;
        fullMyTotal = 0;

        // Define categories to exclude from the My Share total calculation (case-insensitive)
        const myShareExcludedCategories = new Set([
            "credit card payments",
            "transfers",
            "my payments"
        ]);
        
        // Define categories to exclude from the Full Total calculation
        // This is the V7 logic being reapplied to fix the grand total amount.
        const fullTotalExcludedCategories = new Set([
            "my payments" // Exclude 'my payments' from the Full Total sum
        ]);
        
        displayedTransactions.forEach(t => {
            // 1. Calculate Full Original Total (Excluding 'My Payments' which are positive credits/deposits)
            if (!fullTotalExcludedCategories.has(t.category.toLowerCase())) {
                fullOriginalTotal += t.originalAmount; 
            }

            // 2. Calculate My Share Total 
            // Only include in My Total if the category is NOT in the excluded list
            if (!myShareExcludedCategories.has(t.category.toLowerCase())) {
                fullMyTotal += t.myTotal;
            } else {
                // We do nothing if it's excluded, as handled by the IF above.
            }
        });
        
        updateTotalsDisplay();
    }
    
    // NEW FUNCTION - CORE FIX: Re-sorts displayedTransactions using the current global sort state.
    // Does NOT flip the direction, thus preserving the user's view.
    function reapplyCurrentSort() {
        const key = transactionSort.key;
        const direction = transactionSort.direction;
        
        displayedTransactions.sort((a, b) => {
            const aVal = a[key];
            const bVal = b[key];
            let comparison = 0;

            if (key === 'dateObj') {
                const aTime = aVal ? aVal.getTime() : 0;
                const bTime = bVal ? bVal.getTime() : 0;
                comparison = aTime - bTime;
            } else if (typeof aVal === 'number' && typeof bVal === 'number') {
                comparison = aVal - bVal;
            } else {
                // Handle null/undefined values gracefully
                const strA = String(aVal || '');
                const strB = String(bVal || '');
                comparison = strA.localeCompare(strB);
            }
            
            return direction === 'asc' ? comparison : -comparison;
        });
        
        updateSortIndicators('transactions-list', transactionSort);
        renderTransactions();
    }
    
    // --- End Utility Functions ---

    // --- Trigger File Input ---
    function triggerFileUpload(type) {
        currentImportType = type;
        document.getElementById('csv-file-input').click();
    }

    // --- Tab Switching ---
    function openTab(tabId, element) {
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
        document.querySelectorAll('.tab-button').forEach(button => button.classList.remove('active'));

        document.getElementById(tabId).classList.add('active');
        element.classList.add('active');

        if (tabId === 'imports-tab') {
            renderImportsHistory();
        } else if (tabId === 'category-breakdown-tab') {
            applyBreakdownFilter(); // Trigger calculation on tab switch
        }
    }

    // --- File Handling Functions ---
    function initializeFileUpload(event) {
        const fileList = event.target.files;
        if (fileList.length > 0) {
            filesToProcess.push(...Array.from(fileList));
            event.target.value = null;
            processNextFileInQueue();
        }
    }

    function processNextFileInQueue() {
        if (filesToProcess.length > 0) {
            currentProcessingFile = filesToProcess.shift();
            
            if (currentImportType === 'old') {
                // SKIP CC MODAL for old data. Pass the skip constant.
                handleCreditCardSelection(SKIP_CC_SELECTION);
            } else {
                // Regular process: show modal for new data
                document.getElementById('cc-modal-title').textContent = `Select Card for: ${currentProcessingFile.name}`;
                openModal('creditCardSelectModal');
            }
        } else {
            processTransactions();
        }
    }

    function handleCreditCardSelection(selectedCard) {
        // Hide modal if it was open (including if the selection was a real click)
        document.getElementById('creditCardSelectModal').style.display = 'none';

        const file = currentProcessingFile;
        if (!file) {
            processNextFileInQueue();
            return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
            const csvData = e.target.result;
            // Pass the import type to parseCSV for logic branching
            const newTransactions = parseCSV(csvData, selectedCard, file.name, currentImportType);
            
            transactions.push(...newTransactions);
            
            if (newTransactions.length > 0) {
                // Only record file history if transactions were successfully parsed and included
                const newFileId = importedFilesHistory.length + 1;
                importedFilesHistory.push({
                    id: newFileId,
                    fileName: file.name,
                    creditCard: selectedCard,
                    transactionCount: newTransactions.length,
                    dateAdded: new Date().toLocaleDateString()
                });
            }

            // Continue processing the next file or finish
            processNextFileInQueue();
        };
        reader.readAsText(file);
    }

    function renderImportsHistory() {
        const tbody = document.getElementById('imports-body');
        tbody.innerHTML = '';

        if (importedFilesHistory.length === 0) {
            tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #666; padding: 20px;">No files have been imported yet.</td></tr>';
            return;
        }

        // Filter out the 'Manual Entry' file which is not managed here
        const filteredHistory = importedFilesHistory.filter(f => f.id !== MANUAL_ENTRY_ID);

        if (filteredHistory.length === 0) {
            tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #666; padding: 20px;">No files have been imported yet.</td></tr>';
            return;
        }
        
        filteredHistory.forEach(file => {
            const row = tbody.insertRow();
            row.insertCell().textContent = file.fileName;
            row.insertCell().textContent = file.creditCard;
            row.insertCell().textContent = file.transactionCount;
            
            const actionsCell = row.insertCell();
            actionsCell.innerHTML = `
                <div class="import-actions-grid">
                    <button onclick="openReassignModal(${file.id})">Re-assign Card</button>
                    <button class="btn-delete" onclick="deleteImportedFile(${file.id})">Delete</button>
                </div>
            `;
        });
    }

    function openReassignModal(fileId) {
        if (fileId === MANUAL_ENTRY_ID) return; // Cannot reassign the manual entry group
        
        const fileEntry = importedFilesHistory.find(f => f.id === fileId);
        if (!fileEntry) return;

        reassigningFileIndex = fileId;
        document.getElementById('reassign-file-name').textContent = fileEntry.fileName;

        // Clone and replace the container to wipe out old event listeners and re-attach
        const oldContainer = document.getElementById('reassign-buttons-container');
        const newContainer = oldContainer.cloneNode(true);
        oldContainer.parentNode.replaceChild(newContainer, oldContainer);
        newContainer.id = 'reassign-buttons-container';

        const buttons = newContainer.querySelectorAll('button');
        buttons.forEach(button => {
            const cardName = button.textContent;
            button.onclick = () => reassignCreditCard(fileId, cardName);
        });

        openModal('changeCCModal');
    }

    function reassignCreditCard(fileId, newCard) {
        const fileEntry = importedFilesHistory.find(f => f.id === fileId);
        if (!fileEntry) return;

        transactions.forEach(t => {
            if (t.fileName === fileEntry.fileName) {
                t.creditCard = newCard;
            }
        });
        
        fileEntry.creditCard = newCard;
        closeModal('changeCCModal');
        renderImportsHistory();
        applyDateFilter();
    }

    function deleteImportedFile(fileId) {
        if (fileId === MANUAL_ENTRY_ID) {
            // Manual entries are now deleted via the in-line button, but keep this check for safety.
            alert('Manual entries are managed via the Edit/Delete button in the transaction list.');
            return;
        } else {
            if (!confirm('Are you sure you want to delete this file and all its associated transactions? This action cannot be undone.')) return;

            const fileEntry = importedFilesHistory.find(f => f.id === fileId);
            if (!fileEntry) return;

            const fileNameToDelete = fileEntry.fileName;

            // Remove transactions associated with the file
            transactions = transactions.filter(t => t.fileName !== fileNameToDelete);
            
            // Remove the file entry from history
            importedFilesHistory = importedFilesHistory.filter(f => f.id !== fileId);

            // Re-render and update totals
            renderImportsHistory();
            processTransactions();
        }
    }


    // --- CSV Parsing Logic ---
    function parseCSV(csv, creditCard, fileName, importType) {
        const lines = csv.split('\n').filter(line => line.trim() !== '');
        if (lines.length === 0) return [];

        const headerLine = lines[0];
        const dataLines = lines.slice(1);

        // Simple CSV line parser that handles quoted fields
        function parseLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result;
        }

        const headers = parseLine(headerLine);
        
        // Map header names to their column index
        const headerMap = headers.reduce((acc, header, index) => {
            const cleanCol = header.trim().toLowerCase();
            acc[cleanCol] = index;
            // Catch variations of credit card column
            if (cleanCol.includes('credit card') || cleanCol.includes('cc') || cleanCol.includes('card name') || cleanCol.includes('account')) {
                acc['credit card from csv'] = index;
            }
            return acc;
        }, {});

        const dateIndex = headerMap['date'];
        const descIndex = headerMap['description'];
        const categoryIndex = headerMap['category'];
        // Check for 'amount' first, then fallback to 'original amount' for compatibility
        const amountIndex = headerMap['amount'] !== undefined ? headerMap['amount'] : headerMap['original amount'];
        const ccCsvIndex = headerMap['credit card from csv'];

        // INDICES FOR RE-IMPORTING OLD/EXPORTED DATA
        const myTotalIndex = headerMap['my total'];
        const statusIndex = headerMap['split status'];
        const notesIndex = headerMap['notes'];

        if (dateIndex === undefined || amountIndex === undefined) {
            alert(`File "${fileName}" skipped: CSV must contain 'Date' and one of 'Amount' or 'Original Amount' columns (case-insensitive).`);
            return [];
        }

        const parsedData = [];
        dataLines.forEach(line => {
            const values = parseLine(line);
            if (values.length > 0) {
                const amountStr = values[amountIndex] || '0';
                // Remove non-numeric characters except for '-' and '.'
                const originalAmount = parseFloat(amountStr.replace(/[^0-9.-]/g, '')) || 0; 
                
                // Skip row if it looks like a non-zero value but parsed to 0
                if (originalAmount === 0 && amountStr.replace(/[^0-9.-]/g, '').trim() !== '0') return; 

                const category = (values[categoryIndex] || 'Uncategorized').trim(); // Trim category

                // Exclude "credit card payments" and "transfers"
                if (EXCLUDED_CATEGORIES.includes(category.toLowerCase())) {
                    return; // Skip this transaction
                }
                
                uniqueCategories.add(category);

                let finalCreditCard = creditCard;
                let myTotal = 0;
                let status = '';
                let notes = '';

                // LOGIC FOR "OLD DATA" IMPORT
                if (importType === 'old') {
                    // Try to auto-assign credit card from the CSV column if available
                    if (ccCsvIndex !== undefined && values[ccCsvIndex]) {
                         finalCreditCard = values[ccCsvIndex].trim() || finalCreditCard;
                    }
                    
                    // Assign myTotal, status, and notes from the exported file data
                    const myTotalStr = values[myTotalIndex] || '0';
                    myTotal = parseFloat(myTotalStr.replace(/[^0-9.-]/g, '')) || 0;
                    status = (values[statusIndex] || '').trim();
                    notes = (values[notesIndex] || '').trim();
                }

                // If importing "new" data (no myTotal/status columns), set sensible defaults
                if (importType === 'new' || status === '') {
                    // Default behavior for new transactions: full share if it's an expense, 
                    // and half share if it's a credit (or a zero value, though zero should typically be filtered earlier).
                    if (originalAmount <= 0) {
                        // Expense or zero, set to Half by default
                        status = 'Half';
                        myTotal = originalAmount / 2;
                    } else {
                        // Credit (like a refund or a deposit), set to Full by default
                        status = 'Full';
                        myTotal = originalAmount;
                    }
                }
                
                const dateString = (values[dateIndex] || '').trim();
                const dateObj = parseDateInput(dateString);
                
                parsedData.push({
                    id: Date.now() + parsedData.length, // Simple unique ID
                    date: dateString,
                    dateObj: dateObj, // Date object for sorting/filtering
                    creditCard: finalCreditCard,
                    description: (values[descIndex] || 'N/A').trim(),
                    category: category,
                    originalAmount: originalAmount, // Parsed value or default 0
                    myTotal: myTotal, // Set to parsed value or default 0
                    status: status, // Set to parsed value or default ''
                    fileName: fileName,
                    notes: notes // Set to parsed value or default ''
                });
            }
        });

        if (parsedData.length === 0 && dataLines.length > 0) {
            console.warn(`Warning: Found data rows in "${fileName}" but parsed 0 transactions. Check CSV format.`);
        }

        return parsedData;
    }

    function processTransactions() {
        // Initial sort: Date ASC
        transactions.sort((a, b) => {
            if (!a.dateObj) return 1;
            if (!b.dateObj) return -1;
            return a.dateObj.getTime() - b.dateObj.getTime();
        });

        transactions.forEach(t => {
            if (t.category) uniqueCategories.add(t.category);
        });

        reRenderCategoryDropdowns();
        applyDateFilter();
    }

    // --- Transaction Sorting and Filtering ---
    function sortTransactions(key) {
        if (transactionSort.key === key) {
            transactionSort.direction = transactionSort.direction === 'asc' ? 'desc' : 'asc';
        } else {
            transactionSort.key = key;
            // Default date sort to ASC (oldest first)
            transactionSort.direction = key === 'dateObj' ? 'asc' : 'desc';
        }
        reapplyCurrentSort(); // Use the dedicated reapply function to sort and render
    }

    function updateSortIndicators(listId, sortState) {
        document.querySelectorAll(`#${listId} th.sortable`).forEach(th => {
            th.classList.remove('asc', 'desc');
            if (th.dataset.sortKey === sortState.key) {
                th.classList.add(sortState.direction);
            }
        });
    }

    function applyDateFilter() {
        const preset = document.getElementById('date-range-preset').value;
        const customRangeDiv = document.getElementById('custom-date-range');
        let startDate = null;
        let endDate = null;

        if (preset === 'custom') {
            customRangeDiv.style.display = 'flex'; // Use flex now that it's a div containing labels/inputs
            startDate = document.getElementById('start-date').value ? parseDateInput(document.getElementById('start-date').value) : null;
            endDate = document.getElementById('end-date').value ? parseDateInput(document.getElementById('end-date').value) : null;
            // Add one day to the end date to make it inclusive until the end of that day
            if (endDate) {
                endDate.setDate(endDate.getDate() + 1);
                endDate.setSeconds(endDate.getSeconds() - 1); // Set to 23:59:59
            }
        } else {
            customRangeDiv.style.display = 'none';

            const now = new Date();
            let start = new Date(now.getFullYear(), now.getMonth(), 1);
            let end = new Date(now.getFullYear(), now.getMonth() + 1, 0); // Last day of month

            if (preset === 'last_month') {
                start = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                end = new Date(now.getFullYear(), now.getMonth(), 0); // Last day of last month
            } else if (preset === 'all_time') {
                // FIX: For 'all_time', we explicitly set startDate and endDate to null 
                // and then continue with the filtering, which will pass all dates.
                // No further date manipulation is needed.
                startDate = null; 
                endDate = null;
            }

            // Only set the dates if the preset is NOT 'all_time'
            if (preset !== 'all_time') { 
                startDate = start;
                // Add one day to the end date to make it inclusive until the end of that day
                endDate = new Date(end.getFullYear(), end.getMonth(), end.getDate() + 1);
                endDate.setSeconds(endDate.getSeconds() - 1); // Set to 23:59:59
            }
        }

        displayedTransactions = transactions.filter(t => {
            const date = t.dateObj;
            if (!date) return false; // Filter out transactions with invalid dates
            
            const meetsStart = !startDate || date >= startDate;
            const meetsEnd = !endDate || date <= endDate;
            
            return meetsStart && meetsEnd;
        });
        
        reapplyCurrentSort();
        calculateTotals();
    }

    // --- Render Functions ---
    function getActionButtonsHTML(t, index) {
        const status = t.status || '';
        const isNA = status === 'N/A';
        const isFull = status === 'Full';
        const isHalf = status === 'Half';
        const isCustom = status.includes('Split') || status.includes('Custom');

        const naClass = isNA ? 'applied' : '';
        const fullClass = isFull ? 'applied' : '';
        const halfClass = isHalf ? 'applied' : '';
        const customClass = (isCustom && !isHalf) ? 'applied' : '';

        // The Edit button is ONLY for manual entries
        const manualEditButtonHTML = (t.fileName === 'Manual Entry') ? 
            `<button class="btn-edit-manual action-button" onclick="openEditTransactionModal(${index})">Edit</button>` : '';

        return `
            <div class="action-buttons-grid">
                <button class="btn-split-half action-button ${halfClass}" onclick="applySplitHalf(${index})">Half</button>
                <button class="btn-full action-button ${fullClass}" onclick="applySplitFull(${index})">Full</button>
                <button class="btn-split-custom action-button ${customClass}" onclick="openCustomSplitModal(${index})">Custom</button>
                <button class="btn-na action-button ${naClass}" onclick="applySplitNA(${index})">N/A</button>
                ${manualEditButtonHTML}
                <button class="btn-delete" onclick="deleteTransaction(${index})">Delete</button>
            </div>
        `;
    }
    
    function renderTransactions() {
        const tbody = document.getElementById('transactions-body');
        tbody.innerHTML = '';

        if (displayedTransactions.length === 0) {
            tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; color: #666; padding: 20px;">No transactions match the current filter.</td></tr>';
            updateTotalsDisplay();
            return;
        }

        displayedTransactions.forEach((t, index) => {
            const row = tbody.insertRow();
            row.classList.toggle('na-applied', t.status === 'N/A');

            // Date, Credit Card, Description
            row.insertCell().textContent = formatDate(t.date);
            row.insertCell().textContent = t.creditCard;
            row.insertCell().textContent = t.description;

            // Category (Dropdown)
            const categoryCell = row.insertCell();
            const categorySelect = document.createElement('select');
            categorySelect.className = 'category-select';
            categorySelect.dataset.index = index;
            categorySelect.onchange = (e) => updateTransactionCategory(index, e.target.value);
            
            // Populate the category dropdown
            const categoriesArray = Array.from(uniqueCategories).sort();
            const allCategories = ['Uncategorized', ...categoriesArray.filter(cat => cat !== 'Uncategorized')];
            allCategories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat;
                option.textContent = cat;
                if (t.category === cat) {
                    option.selected = true;
                }
                categorySelect.appendChild(option);
            });
            categoryCell.appendChild(categorySelect);

            // Original Amount & My Total
            const originalAmountCell = row.insertCell();
            originalAmountCell.textContent = formatCurrency(t.originalAmount);
            originalAmountCell.classList.add(t.originalAmount < 0 ? 'negative' : 'positive');

            const myTotalCell = row.insertCell();
            myTotalCell.textContent = formatCurrency(t.myTotal);
            myTotalCell.classList.add(t.myTotal < 0 ? 'negative' : 'positive');

            // Actions (Buttons)
            const actionsCell = row.insertCell();
            actionsCell.innerHTML = getActionButtonsHTML(t, index);

            // Notes (Input)
            const notesCell = row.insertCell();
            const notesInput = document.createElement('input');
            notesInput.type = 'text';
            notesInput.className = 'notes-input';
            notesInput.value = t.notes || '';
            notesInput.onchange = (e) => updateTransactionNotes(index, e.target.value);
            notesCell.appendChild(notesInput);
        });
        
        updateTotalsDisplay();
    }

    // --- Action Handlers ---
    function applyAction(action, index, customValue = null) {
        const t = displayedTransactions[index];
        if (!t) return;
        
        // Find the corresponding transaction in the full list
        const originalTIndex = transactions.findIndex(origT => origT.date === t.date && origT.description === t.description && origT.originalAmount === t.originalAmount && origT.fileName === t.fileName);
        const targetT = originalTIndex !== -1 ? transactions[originalTIndex] : t;
        
        // Logic to update the transaction object
        switch (action) {
            case 'half':
                targetT.myTotal = targetT.originalAmount / 2;
                targetT.status = 'Half';
                break;
            case 'full':
                // For expenses (negative), 'Full' means the full amount (100% split).
                // For refunds/credits (positive), 'Full' also means the full amount.
                targetT.myTotal = targetT.originalAmount; 
                targetT.status = 'Full';
                break;
            case 'na':
                targetT.myTotal = 0;
                targetT.status = 'N/A';
                break;
            case 'custom':
                targetT.myTotal = parseFloat(customValue);
                targetT.status = 'Custom Split';
                break;
            case 'custom-portion':
                // This is the old custom split logic, now handled by the new modal
                targetT.status = 'Custom Split';
                // The new custom split function will overwrite myTotal
                targetT.myTotal = parseFloat(customValue);
                break;
        }

        // FIX (part 2 of 2): Recalculate totals and re-render using the existing sort state.
        calculateTotals();
        reapplyCurrentSort();
    }

    function applySplitHalf(index) {
        applyAction('half', index);
    }

    function applySplitFull(index) {
        applyAction('full', index);
    }

    function applySplitNA(index) {
        applyAction('na', index);
    }

    function updateTransactionNotes(index, value) {
        const t = displayedTransactions[index];
        if (t) {
            // Find the original transaction in the full list to ensure persistence
            const originalTIndex = transactions.findIndex(origT => origT.date === t.date && origT.description === t.description && origT.originalAmount === t.originalAmount && origT.fileName === t.fileName);
            const targetT = originalTIndex !== -1 ? transactions[originalTIndex] : t;
            
            targetT.notes = value;
            t.notes = value; // Also update the displayed one
        }
    }

    function updateTransactionCategory(index, newCategory) {
        const t = displayedTransactions[index];
        if (t) {
            // Find the original transaction in the full list to ensure persistence
            const originalTIndex = transactions.findIndex(origT => origT.date === t.date && origT.description === t.description && origT.originalAmount === t.originalAmount && origT.fileName === t.fileName);
            const targetT = originalTIndex !== -1 ? transactions[originalTIndex] : t;
            
            targetT.category = newCategory;
            t.category = newCategory; // Also update the displayed one

            // No full re-render/re-sort needed, but we do need to recalculate totals
            calculateTotals();
            // Re-render only to update the category in the breakdown tab
            applyBreakdownFilter();
        }
    }

    // --- Custom Split Modal Handlers (UPDATED) ---
    function openCustomSplitModal(index) {
        currentTransactionIndex = index; // Store the index globally
        const t = displayedTransactions[index];
        if (!t) return;

        document.getElementById('modal-date').textContent = formatDate(t.date);
        document.getElementById('modal-description').textContent = t.description;
        document.getElementById('modal-category').textContent = t.category;
        document.getElementById('modal-original-amount').textContent = formatCurrency(t.originalAmount);

        // Determine if it's a refund/credit or transaction/expense for default radio
        const typeSelection = t.originalAmount > 0 ? 'refund' : 'transaction';
        
        // Reset inputs and set the type based on original amount
        document.getElementById('custom-amount-input').value = Math.abs(t.myTotal).toFixed(2);
        document.querySelector(`input[name="custom-type"][value="${typeSelection}"]`).checked = true;

        openModal('customSplitModal');
    }

    function applyCustomSplit() {
        const amountInput = document.getElementById('custom-amount-input');
        const customAmountRaw = parseFloat(amountInput.value);
        const typeSelection = document.querySelector('input[name="custom-type"]:checked').value;
        const t = displayedTransactions[currentTransactionIndex];

        if (isNaN(customAmountRaw) || customAmountRaw <= 0) {
            alert('Please enter a valid positive amount.');
            return;
        }

        // The amount entered is always positive. We apply the sign based on type.
        let myTotal;
        if (typeSelection === 'transaction') {
            // Transaction (Expense): My Total should be negative. Amount entered is ABSOLUTE.
            myTotal = -customAmountRaw;
        } else {
            // Refund (Credit): My Total should be positive. Amount entered is ABSOLUTE.
            myTotal = customAmountRaw;
        }
        
        // Apply logic: myTotal cannot be larger in magnitude than the originalAmount.
        // We use Math.abs() to compare magnitudes.
        if (Math.abs(myTotal) > Math.abs(t.originalAmount)) {
            alert(`My Total cannot be greater than the absolute Original Amount (${formatCurrency(Math.abs(t.originalAmount))}).`);
            return;
        }
        
        // Apply the action and close
        applyAction('custom', currentTransactionIndex, myTotal);
        closeModal('customSplitModal');
    }

    // --- Manual Transaction Handlers ---

    // Function to open the modal for adding (index=null) or editing (index!=null)
    function openEditTransactionModal(index = null) {
        const modal = document.getElementById('manualTransactionModal');
        const saveBtn = document.getElementById('manual-save-btn');
        const isEditing = index !== null;
        editingTransactionIndex = index;

        // Reset form
        modal.dataset.context = isEditing ? 'edit' : 'add';
        document.querySelector('#manualTransactionModal h2').textContent = isEditing ? 'Edit Transaction' : 'Add Manual Transaction';
        saveBtn.textContent = isEditing ? 'Save Changes' : 'Save Transaction';

        // Clear all inputs
        document.getElementById('manual-date').value = '';
        document.getElementById('manual-cc').value = 'Manual';
        document.getElementById('manual-desc').value = '';
        document.getElementById('manual-original-amount').value = '';
        document.getElementById('manual-my-total').value = '';
        document.getElementById('manual-notes').value = '';

        // Reset split buttons
        document.querySelectorAll('#manual-split-buttons .action-button').forEach(btn => btn.classList.remove('applied'));
        document.getElementById('manual-my-total').disabled = false;
        
        // Ensure categories are up-to-date
        reRenderCategoryDropdowns('manual-category');

        if (isEditing) {
            const t = displayedTransactions[index];
            if (!t) return;

            // Format date for input[type="date"] (YYYY-MM-DD)
            const formattedDate = t.dateObj ? t.dateObj.toISOString().split('T')[0] : '';

            document.getElementById('manual-date').value = formattedDate;
            document.getElementById('manual-cc').value = t.creditCard;
            document.getElementById('manual-desc').value = t.description;
            document.getElementById('manual-category').value = t.category;
            document.getElementById('manual-original-amount').value = t.originalAmount;
            document.getElementById('manual-my-total').value = t.myTotal;
            document.getElementById('manual-notes').value = t.notes;

            // Set split button status
            document.querySelectorAll('#manual-split-buttons .action-button').forEach(btn => {
                if (btn.dataset.action === t.status.toLowerCase().replace(' ', '-').split(' ')[0]) {
                    btn.classList.add('applied');
                    if (btn.dataset.action !== 'custom') {
                        document.getElementById('manual-my-total').disabled = true;
                    }
                }
            });

            // Add Delete button only in edit mode
            const actionButtons = document.getElementById('manual-modal-action-buttons');
            let deleteBtn = document.getElementById('manual-delete-btn');
            if (!deleteBtn) {
                deleteBtn = document.createElement('button');
                deleteBtn.id = 'manual-delete-btn';
                deleteBtn.textContent = 'Delete Transaction';
                deleteBtn.className = 'btn-delete';
                // Use the new generalized delete function
                deleteBtn.onclick = () => {
                    deleteTransaction(index); 
                    closeModal('manualTransactionModal');
                };
                // Insert Delete button before Cancel button
                actionButtons.insertBefore(deleteBtn, actionButtons.children[1]); 
            }
        } else {
             // Remove Delete button if present in Add mode
            const deleteBtn = document.getElementById('manual-delete-btn');
            if (deleteBtn) deleteBtn.remove();
        }

        openModal('manualTransactionModal');
    }

    // Helper to handle auto-calculation for manual entry
    function handleManualAmountChange() {
        const originalAmountInput = document.getElementById('manual-original-amount');
        const myTotalInput = document.getElementById('manual-my-total');
        const originalAmount = parseFloat(originalAmountInput.value);

        if (isNaN(originalAmount)) return;
        
        const selectedAction = document.querySelector('#manual-split-buttons .action-button.applied');
        const status = selectedAction ? selectedAction.dataset.action : 'full'; // Default to full
        
        let myTotal;

        if (status === 'full') {
            myTotal = originalAmount;
        } else if (status === 'half') {
            myTotal = originalAmount / 2;
        } else if (status === 'na') {
            myTotal = 0;
        } else {
            // Keep current value if custom split is selected
            return;
        }
        
        myTotalInput.value = myTotal.toFixed(2);
    }
    
    // Helper to handle button selection logic
    function handleManualSplitAction(action) {
        document.querySelectorAll('#manual-split-buttons .action-button').forEach(btn => btn.classList.remove('applied'));
        
        const selectedBtn = document.querySelector(`#manual-split-buttons button[data-action="${action}"]`);
        if (selectedBtn) {
            selectedBtn.classList.add('applied');
        }
        
        const myTotalInput = document.getElementById('manual-my-total');
        
        // Disable My Total input if not custom split
        const disableMyTotal = (action !== 'custom');
        myTotalInput.disabled = disableMyTotal;
        
        // Recalculate if we switched to a non-custom, non-N/A action
        if (action === 'full' || action === 'half') {
            handleManualAmountChange();
        } else if (action === 'na') {
             myTotalInput.value = '0.00';
        }
    }
    
    function openManualCustomSplitModal() {
        // Simple alert/prompt or use the Custom Split modal logic if desired
        alert('For Custom Split, please enter the desired My Total amount below.');
        handleManualSplitAction('custom'); // Ensure the custom button is highlighted
        document.getElementById('manual-my-total').focus();
    }
    
    // If user manually edits myTotal, force the status to 'custom'
    function handleManualMyTotalInput() {
        const selectedAction = document.querySelector('#manual-split-buttons .action-button.applied');
        if (!selectedAction || selectedAction.dataset.action !== 'custom') {
            handleManualSplitAction('custom'); 
        }
    }

    function saveManualTransaction() {
        const dateInput = document.getElementById('manual-date');
        const ccInput = document.getElementById('manual-cc');
        const descInput = document.getElementById('manual-desc');
        const categoryInput = document.getElementById('manual-category');
        const originalAmountInput = document.getElementById('manual-original-amount');
        const myTotalInput = document.getElementById('manual-my-total');
        const notesInput = document.getElementById('manual-notes');

        if (!dateInput.value || !originalAmountInput.value) {
            alert('Date and Original Amount are required.');
            return;
        }

        const originalAmount = parseFloat(originalAmountInput.value);
        const myTotal = parseFloat(myTotalInput.value);

        // Validation for myTotal magnitude
        if (Math.abs(myTotal) > Math.abs(originalAmount)) {
            alert("My Total amount cannot be greater than the Original Amount magnitude.");
            return;
        }

        const dateObj = parseDateInput(dateInput.value);
        
        // Determine Status
        const selectedAction = document.querySelector('#manual-split-buttons .action-button.applied');
        let status = selectedAction ? selectedAction.dataset.action : '';
        if (status === 'half') status = 'Half'; 
        else if (status === 'full') status = 'Full';
        else if (status === 'na') status = 'N/A';
        else if (status === 'custom') status = 'Custom Split';

        // Set default status if somehow none is applied
        if (status === '') {
            status = 'Full';
        }
        
        const newTransaction = {
            date: dateInput.value,
            dateObj: dateObj,
            creditCard: ccInput.value,
            description: descInput.value || 'Manual Entry',
            category: categoryInput.value || 'Uncategorized',
            originalAmount: originalAmount,
            myTotal: myTotal,
            status: status,
            fileName: 'Manual Entry', // Mark as manual
            notes: notesInput.value || ''
        };

        uniqueCategories.add(newTransaction.category);
        
        if (editingTransactionIndex !== null) {
            // Edit existing transaction (update both in full list and displayed list)
            const oldT = displayedTransactions[editingTransactionIndex];
            
            // Find the original index in the full 'transactions' array to ensure persistence
            const originalIndex = transactions.findIndex(t => t.date === oldT.date && t.description === oldT.description && t.originalAmount === oldT.originalAmount && t.fileName === oldT.fileName);
            
            Object.assign(oldT, newTransaction); // Update displayed
            if (originalIndex !== -1) {
                Object.assign(transactions[originalIndex], newTransaction); // Update full list
            }
        } else {
            // Add new transaction
            transactions.push(newTransaction);

            // Ensure the 'Manual Entry' file is added to history if it doesn't exist
            if (!importedFilesHistory.find(f => f.id === MANUAL_ENTRY_ID)) {
                 importedFilesHistory.push({
                    id: MANUAL_ENTRY_ID,
                    fileName: 'Manual Entry',
                    creditCard: 'Manual',
                    transactionCount: 1,
                    dateAdded: new Date().toLocaleDateString()
                });
            } else {
                 // Increment the count
                 importedFilesHistory.find(f => f.id === MANUAL_ENTRY_ID).transactionCount++;
            }
        }

        closeModal('manualTransactionModal');
        // FIX: Recalculate totals and re-render with re-applied filters/sort
        applyDateFilter(); 
    }

    // NEW: Generalized delete function
    function deleteTransaction(index) {
        if (!confirm('Are you sure you want to delete this transaction? This action cannot be undone.')) return;
        
        // 1. Get the transaction object from the currently displayed list
        const t = displayedTransactions[index];

        // 2. Find the original index in the full 'transactions' array to ensure persistence
        const originalIndex = transactions.findIndex(origT => 
            origT.date === t.date && 
            origT.description === t.description && 
            origT.originalAmount === t.originalAmount && 
            origT.fileName === t.fileName
        );

        if (originalIndex !== -1) {
            // 3. Remove from the main data array
            transactions.splice(originalIndex, 1);
            
            // 4. If it was a Manual Entry, update the count in the import history
            if (t.fileName === 'Manual Entry') {
                const manualFile = importedFilesHistory.find(f => f.id === MANUAL_ENTRY_ID);
                if (manualFile) {
                    manualFile.transactionCount--;
                    if (manualFile.transactionCount <= 0) {
                         importedFilesHistory = importedFilesHistory.filter(f => f.id !== MANUAL_ENTRY_ID);
                    }
                }
            }
        }

        // 5. Re-render and update totals
        applyDateFilter();
    }


    // --- Category Management ---
    function reRenderCategoryDropdowns(targetId = null) {
        // Logic to build the option list
        const renderOptions = (selectedValue) => {
            const categoriesArray = Array.from(uniqueCategories).sort();
            const allCategories = ['Uncategorized', ...categoriesArray.filter(cat => cat !== 'Uncategorized')];
            
            return allCategories.map(cat => 
                `<option value="${cat}" ${selectedValue === cat ? 'selected' : ''}>${cat}</option>`
            ).join('');
        };

        // Update Manual Entry Modal dropdown
        if (targetId === 'manual-category') {
            const select = document.getElementById('manual-category');
            if (select) {
                const selectedValue = select.value;
                select.innerHTML = renderOptions(selectedValue);
            }
            return;
        }
        
        // Re-render all category selects in the table
        document.querySelectorAll('.category-select').forEach(select => {
            const selectedValue = select.value;
            select.innerHTML = renderOptions(selectedValue);
        });
    }

    function openNewCategoryModal() {
        document.getElementById('new-category-name-input').value = '';
        openModal('newCategoryModal');
    }

    function addNewCategory() {
        const newCatName = document.getElementById('new-category-name-input').value.trim();
        if (newCatName && !uniqueCategories.has(newCatName)) {
            uniqueCategories.add(newCatName);
            reRenderCategoryDropdowns();
            applyBreakdownFilter();
            closeModal('newCategoryModal');
        } else if (uniqueCategories.has(newCatName)) {
            alert('Category already exists.');
        } else {
            alert('Please enter a category name.');
        }
    }

    function openManageCategoryModal(category) {
        currentManagingCategory = category;
        document.getElementById('current-category-name-display').textContent = category;
        document.getElementById('new-category-name').value = category;
        openModal('manageCategoryModal');
    }

    function performRenameCategory() {
        const oldCat = currentManagingCategory;
        const newCat = document.getElementById('new-category-name').value.trim();

        if (!newCat || newCat === oldCat) {
            alert('Invalid or unchanged category name.');
            return;
        }
        if (uniqueCategories.has(newCat)) {
            alert(`Category "${newCat}" already exists. Cannot rename.`);
            return;
        }

        // 1. Update transactions
        transactions.forEach(t => {
            if (t.category === oldCat) {
                t.category = newCat;
            }
        });

        // 2. Update set
        uniqueCategories.delete(oldCat);
        uniqueCategories.add(newCat);

        // 3. Refresh UI
        reRenderCategoryDropdowns();
        applyBreakdownFilter(); // Recalculates and re-renders breakdown list
        renderTransactions(); // Re-renders transaction list with new dropdowns
        closeModal('manageCategoryModal');
    }

    function deleteCategory(categoryToDelete) {
        if (!confirm(`Are you sure you want to delete the category "${categoryToDelete}"? All transactions in this category will be moved to "Uncategorized".`)) return;

        // 1. Update transactions
        transactions.forEach(t => {
            if (t.category === categoryToDelete) {
                t.category = 'Uncategorized';
            }
        });
        
        // Ensure 'Uncategorized' exists after moving items
        uniqueCategories.add('Uncategorized');

        // 2. Update set
        uniqueCategories.delete(categoryToDelete);

        // 3. Refresh UI
        reRenderCategoryDropdowns();
        applyBreakdownFilter(); 
        renderTransactions(); 
        closeModal('manageCategoryModal');
    }


    // --- Category Breakdown Tab Functions ---
    // NEW CONSTANT: The category to exclude from the breakdown calculation
    const EXCLUDED_FOR_CALC = "my payments";

    function applyBreakdownFilter() {
        const preset = document.getElementById('breakdown-date-range-preset').value;
        let startDate = null;
        let endDate = null;

        const now = new Date();
        let start = new Date(now.getFullYear(), now.getMonth(), 1);
        let end = new Date(now.getFullYear(), now.getMonth() + 1, 0); // Last day of month

        if (preset === 'last_month') {
            start = new Date(now.getFullYear(), now.getMonth() - 1, 1);
            end = new Date(now.getFullYear(), now.getMonth(), 0); // Last day of last month
        } else if (preset === 'all_time') {
            startDate = null;
            endDate = null;
        }

        if (startDate === null && preset !== 'all_time') {
            startDate = start;
            // Add one day to the end date to make it inclusive until the end of that day
            endDate = new Date(end.getFullYear(), end.getMonth(), end.getDate() + 1);
            endDate.setSeconds(endDate.getSeconds() - 1); // Set to 23:59:59
        }

        // Filter transactions based on date range
        const filteredTxns = transactions.filter(t => {
            const date = t.dateObj;
            if (!date) return false;
            const meetsStart = !startDate || date >= startDate;
            const meetsEnd = !endDate || date <= endDate;
            return meetsStart && meetsEnd;
        });

        const breakdown = {};
        let totalOriginalAmountForCalc = 0; // NEW: Total for calculating percentages (excludes 'my payments')
        let totalMyShareForCalc = 0; // NEW: Total for calculating grand total in footer (excludes 'my payments')

        filteredTxns.forEach(t => {
            const cat = t.category || 'Uncategorized';
            const isExcluded = cat.toLowerCase() === EXCLUDED_FOR_CALC;

            if (!breakdown[cat]) {
                breakdown[cat] = {
                    category: cat,
                    count: 0,
                    originalAmount: 0,
                    myTotal: 0,
                    isExcluded: isExcluded // Mark for later rendering
                };
            }

            breakdown[cat].count++;
            breakdown[cat].originalAmount += t.originalAmount;
            breakdown[cat].myTotal += t.myTotal;

            // Only include in the calculation totals if NOT the excluded category
            if (!isExcluded) {
                totalOriginalAmountForCalc += t.originalAmount;
                totalMyShareForCalc += t.myTotal;
            }
        });

        // Convert to array and calculate percentages based on totalOriginalAmountForCalc
        currentBreakdownData = Object.values(breakdown).map(item => {
            let percentage = 0;
            if (!item.isExcluded && totalOriginalAmountForCalc !== 0) {
                percentage = (item.originalAmount / totalOriginalAmountForCalc) * 100;
            }
            
            // NEW: For the excluded category, force amounts and percentage to 0 for display
            const displayOriginalAmount = item.isExcluded ? 0 : item.originalAmount;
            const displayMyTotal = item.isExcluded ? 0 : item.myTotal;
            const displayPercentage = item.isExcluded ? 0 : percentage;

            return {
                ...item,
                originalAmount: displayOriginalAmount, // This is for the item display, zeroed out if excluded
                myTotal: displayMyTotal, // This is for the item display, zeroed out if excluded
                percentage: displayPercentage, // This is for the item display
                isExcluded: item.isExcluded // Keep flag for rendering
            };
        });

        // Apply current breakdown sort
        sortBreakdown(breakdownSort.key);
    }

    function sortBreakdown(key) {
        if (breakdownSort.key === key) {
            breakdownSort.direction = breakdownSort.direction === 'asc' ? 'desc' : 'asc';
        } else {
            breakdownSort.key = key;
            breakdownSort.direction = key === 'percentage' ? 'desc' : 'asc'; // Default to highest percentage first
        }

        const direction = breakdownSort.direction === 'asc' ? 1 : -1;
        
        currentBreakdownData.sort((a, b) => {
            let comparison = 0;
            if (typeof a[key] === 'number' && typeof b[key] === 'number') {
                comparison = a[key] - b[key];
            } else {
                comparison = String(a[key]).localeCompare(String(b[key]));
            }
            return comparison * direction;
        });
        
        updateSortIndicators('category-breakdown-list', breakdownSort);
        
        // Pass the grand totals before rendering (these totals are derived *before* sorting/filtering)
        renderBreakdown(currentBreakdownData.reduce((sum, item) => sum + item.originalAmount, 0), currentBreakdownData.reduce((sum, item) => sum + item.myTotal, 0));
    }


    function renderBreakdown(totalOriginalAmount, totalMyShare) {
        const tbody = document.getElementById('breakdown-body');
        const tfoot = document.getElementById('breakdown-footer');
        tbody.innerHTML = '';
        tfoot.innerHTML = '';

        if (currentBreakdownData.length === 0) {
            tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #666; padding: 20px;">No transactions found for the selected range.</td></tr>';
            return;
        }

        currentBreakdownData.forEach(item => {
            const row = tbody.insertRow();
            row.insertCell().textContent = item.category;
            row.insertCell().textContent = item.count;
            
            // Conditional display based on the isExcluded flag
            if (item.isExcluded) {
                row.insertCell().textContent = ''; // Percentages
                row.insertCell().textContent = ''; // Total Original Amount
                row.insertCell().textContent = ''; // Total My Share
            } else {
                row.insertCell().textContent = `${item.percentage.toFixed(2)}%`;
                row.insertCell().textContent = formatCurrency(item.originalAmount);
                row.insertCell().textContent = formatCurrency(item.myTotal);
            }

            // Actions Cell
            const actionsCell = row.insertCell();
            if (item.category !== 'Uncategorized') {
                actionsCell.innerHTML = `<button onclick="openManageCategoryModal('${item.category}')">Manage</button>`;
            } else {
                actionsCell.textContent = '';
            }
        });

        // Footer Row for Grand Totals
        const footerRow = tfoot.insertRow();
        footerRow.style.fontWeight = 'bold';
        footerRow.style.backgroundColor = '#f0f4f7'; // Light gray background for footer
        
        footerRow.insertCell().textContent = 'GRAND TOTAL:';
        footerRow.insertCell().textContent = currentBreakdownData.reduce((sum, item) => sum + item.count, 0); // Total count
        footerRow.insertCell().textContent = '100.00%'; // Percentage total
        footerRow.insertCell().textContent = formatCurrency(totalOriginalAmount);
        footerRow.insertCell().textContent = formatCurrency(totalMyShare);
        footerRow.insertCell().textContent = ''; // Empty action cell
    }


    // --- Export Functions ---
    function exportToCSV() {
        const today = new Date();
        const todayStr = today.getFullYear() + '-' + String(today.getMonth() + 1).padStart(2, '0') + '-' + String(today.getDate()).padStart(2, '0');
        
        // Headers must match the order expected by the import function for 'old' data
        const headers = ["Date", "Credit Card", "Description", "Category", "Original Amount", "My Total", "Split Status", "File Name", "Notes"];
        const csvRows = [headers.join(',')];
        
        // Helper function to escape commas and quotes in CSV fields
        const clean = (val) => {
            if (val === null || val === undefined) return '';
            let str = String(val).replace(/"/g, '""'); // Escape double quotes with another double quote
            if (str.includes(',') || str.includes('\n')) {
                str = `"${str}"`; // Enclose in quotes if it contains comma or newline
            }
            return str;
        };

        // Use the main transactions list for export, not the filtered one
        transactions.forEach(t => {
            const row = [
                clean(t.date),
                clean(t.creditCard),
                clean(t.description),
                clean(t.category),
                t.originalAmount.toFixed(2), 
                t.myTotal.toFixed(2),
                clean(t.status),
                clean(t.fileName),
                clean(t.notes)
            ];
            csvRows.push(row.join(','));
        });

        const csvString = csvRows.join('\n');
        const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");

        if (link.download !== undefined) { 
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            // MODIFIED: Use the local date string
            link.setAttribute("download", "transaction_export_" + todayStr + ".csv"); 
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } else {
            alert("Your browser does not support downloading files directly. Please copy the data manually.");
        }
    }
    
    // Initial call to set filters and render if data exists (for persistence)
    document.addEventListener('DOMContentLoaded', () => {
         applyDateFilter(); 
         applyBreakdownFilter(); 
    });
</script>

</body>
</html>
