<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transaction Splitter</title>
    <style>
        /* Styling to match Period Tracker V2_13.html */
        *, *::before, *::after {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
              Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif; /* Period App Font */
            margin: 0; 
            padding: 0; 
            background-color: #ffffff; /* Period App Body Background */
            color: #333;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .container {
            /* CHANGES FOR WIDER DESKTOP USE: */
            max-width: none; 
            width: 98%; 
            min-width: 600px; 
            margin: 20px auto;
            /* END CHANGES */

            background-color: #fff;
            padding: 20px;
            border-radius: 8px; 
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); 
            border: 1px solid #cce5ff; 
        }
        h1 {
            /* Style to match the look of the Period App's h2 and header */
            color: #2473BC; 
            border-bottom: 2px solid #76AFE5; 
            padding-bottom: 4px;
            margin-bottom: 1.5rem;
            font-size: 50px; 
            text-align: center;
            font-weight: 700;
        }
        /* --- New #total-container styles for prominence --- */
        #total-container {
            background-color: #eaf3fb; 
            border: 1px solid #cce5ff; 
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 6px; 
            
            display: grid;
            grid-template-columns: 1fr 1fr;
            text-align: center;
            font-weight: 600;
        }
        .total-box {
            display: flex;
            flex-direction: column;
            padding: 10px;
        }
        .total-box.my-share {
            color: #2473BC; /* My Share is primary blue */
            border-right: 1px solid #cce5ff; /* Separator line */
        }
        .total-box.full-total {
            color: #333;
        }
        .total-amount {
            font-size: 2.5em; /* Bigger font for amount */
            font-weight: 700;
            line-height: 1.1;
        }
        .total-label {
            font-size: 0.9em;
            margin-top: 5px;
            color: #666; /* Gray out the label slightly */
        }
        .total-box.my-share .total-label {
            color: #2473BC;
        }
        /* ----------------------------------------------------------------- */
        
        /* --- Import/Export Controls Layout (50/50 Split) --- */
        .controls-wrapper {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px; 
            margin-bottom: 20px;
        }

        /* Removed blue box frame for import/export containers */
        #import-controls-container {
            display: flex; 
            flex-direction: column;
            gap: 10px; 
            padding: 0; 
            border: none; 
            background-color: transparent; 
            border-radius: 6px; 
        }
        
        /* Removed blue box frame for import/export containers */
        #export-frame {
            display: flex;
            flex-direction: column;
            justify-content: center; 
            padding: 0; 
            border: none;
            background-color: transparent;
            border-radius: 6px; 
        }
        
        .import-action-button {
            padding: 12px 20px;
            font-size: 1.1rem;
            background-color: #2473BC;
            color: white;
            width: 100%;
        }

        /* UPDATED STYLING FOR EXPORT BUTTON (Light Blue) */
        #export-frame button {
            padding: 12px 20px;
            font-size: 1.1rem;
            background-color: #CDE6F8; /* Light Blue Background */
            color: #2473BC; /* Primary Blue Text */
            border: 2px solid #76AFE5; /* Border to match the frame */
            width: 100%; 
            height: 100%; 
            margin: 0;
            display: block;
            font-weight: 700;
        }

        /* Hide the actual file input */
        #csv-file-input {
            display: none; 
        }

        /* --- Tab Styling --- */
        .tabs {
            display: flex;
            border-bottom: 2px solid #76AFE5;
            margin-bottom: 20px;
        }
        .tab-button {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            background-color: #f8fbfe;
            color: #2473BC;
            font-weight: 600;
            transition: all 0.2s;
        }
        .tab-button.active {
            border-color: #76AFE5;
            border-bottom: 2px solid white; 
            background-color: white;
            color: #2473BC;
            margin-bottom: -2px; 
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        
        /* --- NEW STYLES FOR TRANSACTION HEADER CONTROLS (Filters + Add Button) --- */
        .transactions-header-controls {
            display: flex; 
            justify-content: space-between; /* Push button to the right */
            align-items: center; /* Vertically align items */
            margin-bottom: 20px;
            gap: 20px; /* Space between filter section and button */
        }

        /* Style the filter section for existing elements */
        #filter-presets {
            display: flex;
            align-items: center;
            gap: 10px; /* Space between filter elements */
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }
        
        /* Style the new button to match the size of a select/input */
        #add-transaction-btn {
            padding: 10px 20px; /* Similar to select padding */
            font-size: 0.95rem; /* Similar to select font size */
            background-color: #2473BC; /* Primary blue color */
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            /* FIX: Ensure width is determined by content only and it doesn't grow */
            width: auto; 
            flex-grow: 0; 
        }
        
        #category-controls {
            display: flex; 
            gap: 10px;
        }
        
        #add-category-btn {
            padding: 10px 15px; 
            font-size: 0.95rem; 
            background-color: #CDE6F8; 
            color: #2473BC; 
            border: 1px solid #76AFE5; 
            border-radius: 6px; 
            font-weight: 600;
            width: auto; 
            flex-grow: 0; 
        }
        /* --- END NEW STYLES --- */


        /* --- Table Styling and Sorting --- */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: left;
            vertical-align: middle; 
        }
        th {
            background-color: #79AFDE; 
            color: white;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        /* Clickable headers */
        th.sortable {
            cursor: pointer;
            position: relative;
        }
        th.sortable::after {
            content: '';
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            border: 4px solid transparent;
            opacity: 0.5;
        }
        th.sortable.asc::after {
            content: '▲';
            opacity: 1;
            font-size: 0.7em;
            right: 5px;
        }
        th.sortable.desc::after {
            content: '▼';
            opacity: 1;
            font-size: 0.7em;
            right: 5px;
        }

        tr:nth-child(even) {
            background-color: #f8fbfe; 
        }

        /* Gray-out style for N/A rows */
        .na-applied td {
            color: #989898; 
            font-style: italic;
        }
        
        .notes-input {
            width: 100%;
            padding: 4px 6px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            font-size: 0.85rem;
        }

        /* --- Buttons and Modals --- */
        .action-buttons-grid, .import-actions-grid {
            display: grid;
            /* MODIFIED: Change to 2 columns for a 2x2 layout */
            grid-template-columns: 1fr 1fr; 
            gap: 5px;
            width: 100%;
        }
        
        /* NEW: Full width for manual entry actions (1 button only now) */
        .action-buttons-grid.single-button {
             grid-template-columns: 1fr;
        }

        .import-actions-grid {
            grid-template-columns: 1fr 1fr; 
        }
        .cc-buttons-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        .cc-buttons-grid button {
            width: 100%;
            font-size: 1rem;
            padding: 12px 5px;
            background-color: #79AFDE;
            color: white;
            border: none;
        }
        
        button {
            padding: 8px 5px; 
            margin: 0; 
            width: 100%; 
            cursor: pointer;
            border: none;
            border-radius: 6px; 
            font-weight: 600; 
            transition: all 0.2s;
            font-size: 0.9rem; 
            box-sizing: border-box; 
        }

        .btn-full, .btn-split-half, .btn-split-custom, .btn-change-cc { 
            background-color: #79AFDE; 
            color: white; 
        } 
        .btn-na, .btn-delete { 
            background-color: #989898; 
            color: white;
        }
        .btn-delete { background-color: #e66666; }

        /* Default state: all buttons are outlines */
        .action-button {
            background-color: transparent !important;
            border: 2px solid #79AFDE; 
            color: #2473BC !important; 
            font-weight: 600;
            padding: 6px 5px; 
        }
        .btn-na.action-button { 
            border-color: #989898; 
            color: #989898 !important;
        }

        /* Action Applied State (Turns into a solid-filled button) */
        .btn-full.applied, .btn-split-half.applied, .btn-split-custom.applied { 
            background-color: #79AFDE !important; 
            color: white !important; 
            border: none;
        }
        
        /* OVERRIDE: Set Full button to the main blue color (#2473BC) when applied */
        .btn-full.applied {
            background-color: #2473BC !important; 
            color: white !important; 
            border: none !important;
        }

        .btn-na.applied { 
            background-color: #989898 !important; 
            color: white !important; 
            border: none;
        }


        .negative { color: black; } 
        .positive { color: green; } 

        select, input[type="number"], input[type="text"], input[type="date"] {
            padding: 8px 10px;
            border-radius: 6px;
            border: 1px solid #cce5ff; 
            margin-right: 10px;
            box-sizing: border-box;
            font-size: 0.95rem;
            min-width: 150px; 
        }

        /* Target all select elements in the table for a small padding */
        .category-select {
            width: 100%;
            padding: 6px 8px; 
            font-size: 0.85rem;
        }
        
        /* --- Modal Styling Updates --- */
        .modal {
            display: none; 
            position: fixed; 
            z-index: 100; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.4); 
        }
        .modal-content {
            background-color: #fefefe;
            margin: 10% auto; 
            padding: 25px;
            border: 1px solid #76AFE5; 
            width: 90%; 
            max-width: 500px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(36, 115, 188, 0.2); 
            position: relative; /* REQUIRED for close-btn positioning */
        }
        
        /* Custom Split Modal Row Spacing */
        .modal-details div, 
        .modal-field {
            margin-bottom: 10px; 
        }
        
        /* Styling for the manual transaction form fields */
        #manualTransactionModal .modal-field {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        #manualTransactionModal .modal-field label {
            font-weight: 600;
            font-size: 0.9em;
            color: #333;
        }
        #manualTransactionModal .modal-field input, 
        #manualTransactionModal .modal-field select {
            min-width: 100%;
            box-sizing: border-box;
            margin: 0;
        }
        
        /* Make the modal button row three columns when editing (Save, Delete, Cancel) */
        #manualTransactionModal .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        #manualTransactionModal .modal-buttons button {
            flex: 1;
	margin-top: 20px;
        }
        
        /* Ensure split buttons in modal don't stretch vertically */
        #manual-split-buttons button {
            height: auto; 
            padding: 6px 5px;
        }


        /* Close button positioning */
        .close-btn {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            position: absolute; 
            top: 10px; 
            right: 15px; 
            cursor: pointer;
            line-height: 1; 
            padding: 0;
            margin: 0;
            background: none; 
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Transaction Splitter</h1>

    <div class="controls-wrapper">
        
        <div id="import-controls-container">
            <button class="import-action-button" onclick="triggerFileUpload('new')">Import Transactions</button>
            <button class="import-action-button" onclick="triggerFileUpload('old')">Import Old Data</button>
        </div>

        <div id="export-frame">
            <button onclick="exportToCSV()">Export All Data to CSV</button>
        </div>
        
        <input type="file" id="csv-file-input" accept=".csv" multiple>
    </div>

    <div class="tabs">
        <button class="tab-button active" onclick="openTab('transactions-tab', this)">Transactions</button>
        <button class="tab-button" onclick="openTab('imports-tab', this)">File Imports</button>
        <button class="tab-button" onclick="openTab('category-breakdown-tab', this)">Category Breakdown</button>
    </div>

    <div id="transactions-tab" class="tab-content active">
        <div id="total-container">
            <div class="total-box my-share">
                <span id="full-my-total" class="total-amount">$0.00</span>
                <span class="total-label">My Share</span>
            </div>
            <div class="total-box full-total">
                <span id="full-original-total" class="total-amount">$0.00</span>
                <span class="total-label">Full Total Amount</span>
            </div>
        </div>
        <div id="filter-controls" class="transactions-header-controls">
            <div id="filter-presets">
                <label for="date-range-preset">View Range:</label>
                <select id="date-range-preset" onchange="applyDateFilter()">
                    <option value="current_month">This Month</option>
                    <option value="last_month">Last Month</option>
                    <option value="all_time">All Time</option>
                    <option value="custom">Custom Range</option>
                </select>

                <div id="custom-date-range" style="display: none;">
                    <label for="start-date">Start Date:</label>
                    <input type="date" id="start-date" onchange="applyDateFilter()">
                    
                    <label for="end-date">End Date:</label>
                    <input type="date" id="end-date" onchange="applyDateFilter()">
                </div>
            </div>
            <div id="category-controls">
                <button id="add-transaction-btn" onclick="openManualTransactionModal()">Add Manual Transaction</button>
                <button id="add-category-btn" onclick="openNewCategoryModal()">Add Category</button>
            </div>
        </div>
        <div id="transactions-list">
            <table>
                <thead>
                    <tr>
                        <th style="width: 8%;" class="sortable" data-sort-key="dateObj" onclick="sortTransactions('dateObj')">Date</th>
                        <th style="width: 10%;">Credit Card</th>
                        <th style="width: 20%;">Description</th>
                        <th style="width: 10%;">Category</th>
                        <th style="width: 8%;">Original Amount</th>
                        <th style="width: 8%;">My Total</th>
                        <th style="width: 16%;">Actions</th>
                        <th style="width: 20%;">Notes</th>
                    </tr>
                </thead>
                <tbody id="transactions-body">
                    </tbody>
            </table>
        </div>
    </div>

    <div id="imports-tab" class="tab-content">
        <h2>Imported Files History</h2>
        <div id="imports-list">
            <table>
                <thead>
                    <tr>
                        <th style="width: 40%;">File Name</th>
                        <th style="width: 25%;">Credit Card</th>
                        <th style="width: 15%;">Transactions</th>
                        <th style="width: 20%;">Actions</th>
                    </tr>
                </thead>
                <tbody id="imports-body">
                </tbody>
            </table>
        </div>
    </div>

    <div id="category-breakdown-tab" class="tab-content">
        <h2>Category Breakdown</h2>
        <div id="breakdown-filter-controls">
            <label for="breakdown-date-range-preset">View Range:</label>
            <select id="breakdown-date-range-preset" onchange="applyBreakdownFilter()">
                <option value="current_month">This Month</option>
                <option value="last_month">Last Month</option>
                <option value="all_time" selected>All Time</option>
            </select>
        </div>
        <div id="category-breakdown-list">
            <table>
                <thead>
                    <tr>
                        <th style="width: 20%;">Category</th>
                        <th style="width: 15%;">Transaction Count</th>
                        <th style="width: 15%;" class="sortable" data-sort-key="percentage" onclick="sortBreakdown('percentage')">Percentages</th>
                        <th style="width: 20%;">Total Original Amount</th>
                        <th style="width: 15%;">Total My Share</th>
                        <th style="width: 15%;">Actions</th> </tr>
                </thead>
                <tbody id="breakdown-body">
                    <tr><td colspan="6" style="text-align: center; color: #666; padding: 20px;">Load transactions to see breakdown.</td></tr>
                </tbody>
                <tfoot id="breakdown-footer"></tfoot>
            </table>
        </div>
    </div>
</div>

<div id="creditCardSelectModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('creditCardSelectModal')">&times;</span>
        <h2 id="cc-modal-title">Select Credit Card for Imported File</h2>
        <p>Please choose which credit card these transactions are from:</p>
        <div id="cc-buttons-container" class="cc-buttons-grid">
            </div>
    </div>
</div>

<div id="changeCCModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('changeCCModal')">&times;</span>
        <h2 id="reassign-cc-title">Reassign Credit Card</h2>
        <p>Select a new card for: <strong id="reassign-file-name"></strong></p>
        <div id="reassign-buttons-container" class="cc-buttons-grid">
            </div>
    </div>
</div>

<div id="customSplitModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('customSplitModal')">&times;</span>
        <h2>Custom Split: Set My Total</h2>

        <div class="modal-details">
            <div><strong>Date:</strong> <span id="modal-date"></span></div>
            <div><strong>Description:</strong> <span id="modal-description"></span></div>
            <div><strong>Category:</strong> <span id="modal-category"></span></div>
            <div><strong>Original Amount:</strong> <span id="modal-original-amount" style="font-weight: bold;">$0.00</span></div>
        </div>

        <div class="modal-field">
            <label style="font-weight: 600;">Transaction Type:</label>
            <div style="display: flex; gap: 20px;">
                <label><input type="radio" name="custom-type" value="transaction" checked> Transaction (Expense)</label>
                <label><input type="radio" name="custom-type" value="refund"> Refund (Credit)</label>
            </div>
        </div>
        
        <div class="modal-field">
            <label for="custom-amount-input" style="font-weight: 600;">Amount to Assign to My Total (Positive Number Only):</label>
            <input type="number" id="custom-amount-input" placeholder="e.g., 55.75" step="0.01" min="0">
        </div>

        <div class="modal-buttons">
            <button onclick="applyCustomSplit()" class="btn-full" style="margin-bottom: 10px; margin-top:25px;">Apply Custom Amount</button>
            <button onclick="closeModal('customSplitModal')" class="btn-na">Cancel</button>
        </div>
    </div>
</div>
<div id="manualTransactionModal" class="modal" data-context="add">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('manualTransactionModal')">&times;</span>
        <h2>Add Manual Transaction</h2>
        
        <div class="modal-field">
            <label for="manual-date">Date <span style="color: red;">*</span></label>
            <input type="date" id="manual-date" required>
        </div>

        <div class="modal-field">
            <label for="manual-cc">Credit Card</label>
            <select id="manual-cc"></select>
        </div>
        
        <div class="modal-field">
            <label for="manual-desc">Description</label>
            <input type="text" id="manual-desc">
        </div>
        
        <div class="modal-field">
            <label for="manual-category">Category</label>
            <select id="manual-category" class="category-select"></select>
        </div>

        <div class="modal-field">
            <label for="manual-original-amount">Original Amount ($) <span style="color: red;">*</span></label>
            <input type="number" id="manual-original-amount" step="0.01" placeholder="e.g., -55.75" required oninput="handleManualAmountChange()">
            <small style="color: #666; margin-top: -5px;">Put minus if a transaction is a charge (e.g., -55.75).</small>
        </div>
        
        <div class="modal-field">
            <label>Split Status</label>
            <div id="manual-split-buttons" class="action-buttons-grid">
                <button class="btn-split-half action-button" data-action="half" onclick="handleManualSplitAction('half')">Half</button>
                <button class="btn-full action-button" data-action="full" onclick="handleManualSplitAction('full')">Full</button>
                <button class="btn-split-custom action-button" data-action="custom" onclick="openManualCustomSplitModal()">Custom Split</button>
                <button class="btn-na action-button" data-action="na" onclick="handleManualSplitAction('na')">N/A</button>
            </div>
        </div>
        
        <div class="modal-field">
            <label for="manual-my-total">My Total ($)</label>
            <input type="number" id="manual-my-total" step="0.01" placeholder="e.g., -27.88" oninput="handleManualMyTotalInput()">
        </div>
        
        <div class="modal-field">
            <label for="manual-notes">Notes</label>
            <input type="text" id="manual-notes">
        </div>

        <div class="modal-buttons" id="manual-modal-action-buttons">
            <button onclick="saveManualTransaction()" class="btn-full" id="manual-save-btn">Save Transaction</button>
            <button onclick="closeModal('manualTransactionModal')" class="btn-na">Cancel</button>
        </div>
    </div>
</div>

<div id="newCategoryModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('newCategoryModal')">&times;</span>
        <h2>Add New Category</h2>
        
        <div class="modal-field">
            <label for="new-category-name-input" style="font-weight: 600;">Category Name:</label>
            <input type="text" id="new-category-name-input" placeholder="e.g., Groceries" required>
        </div>

        <div class="modal-buttons" style="margin-top: 20px;">
            <button onclick="addNewCategory()" class="btn-full" style="background-color: #2473BC; margin-bottom: 10px; margin-top:25px;">Add Category</button>
            <button onclick="closeModal('newCategoryModal')" class="btn-na">Cancel</button>
        </div>
    </div>
</div>
<div id="manageCategoryModal" class="modal">
    <div class="modal-content">
        <span class="close-btn" onclick="closeModal('manageCategoryModal')">&times;</span>
        <h2>Manage Category: <strong id="current-category-name-display"></strong></h2>
        
        <p style="font-weight: bold; margin-top: 10px;">Rename Category</p>
        <div class="modal-field">
            <label for="new-category-name">New Name:</label>
            <input type="text" id="new-category-name" placeholder="Enter new category name">
        </div>
        
        <div class="modal-buttons" style="margin-bottom: 25px;">
            <button onclick="performRenameCategory()" class="btn-full" id="rename-category-btn" style="background-color: #2473BC;">Rename Category</button>
        </div>
        
        <hr style="border-top: 1px solid #cce5ff; margin: 15px 0;">
        
        <p style="font-weight: bold; color: #e66666; margin-bottom: 10px;">Danger Zone: Delete Category</p>
        <div class="modal-buttons">
            <button onclick="deleteCategory(currentManagingCategory)" class="btn-delete">Delete & Re-categorize to 'Uncategorized'</button>
        </div>
        <small style="color: #989898; margin-top: 5px; display: block;">This action cannot be undone.</small>

        <div class="modal-buttons" style="margin-top: 20px;">
            <button onclick="closeModal('manageCategoryModal')" class="btn-na">Close</button>
        </div>
    </div>
</div>
<script>
    // Global Constants
    const CREDIT_CARD_OPTIONS = [
        'Unlimited 3993', 
        'Sapphire 8906', 
        'Target', 
        'My CC',
        'Manual' // Added 'Manual' as a default CC option for manual entries
    ];
    // Special value to signal that card selection was skipped and to look in CSV
    const SKIP_CC_SELECTION = 'OLD_DATA_AUTO_ASSIGN'; 
    
    // Special ID for manual entries, which are now hidden from the imports list
    const MANUAL_ENTRY_ID = 0; 
    
    // Global variables
    let transactions = []; 
    let displayedTransactions = []; 
    let uniqueCategories = new Set();
    let fullOriginalTotal = 0;
    let fullMyTotal = 0;
    let currentTransactionIndex = null; 
    let editingTransactionIndex = null; 
    let currentManagingCategory = null; 
    
    // Sorting State
    let transactionSort = { key: 'dateObj', direction: 'asc' }; 
    let breakdownSort = { key: 'percentage', direction: 'desc' };
    
    // Data structures for file management
    let filesToProcess = []; 
    let currentProcessingFile = null; 
    let importedFilesHistory = []; 
    let reassigningFileIndex = null; 
    let currentImportType = 'new'; // 'new' or 'old'
    let currentBreakdownData = []; // To hold the category data for sorting

    // Event listener for the actual file input (now hidden)
    document.getElementById('csv-file-input').addEventListener('change', initializeFileUpload);
    document.getElementById('date-range-preset').addEventListener('change', applyDateFilter);
    document.getElementById('breakdown-date-range-preset').addEventListener('change', applyBreakdownFilter);

    // Initial setup of CC buttons in the two modals AND the CC dropdown in manual entry modal
    (function setupCCButtons() {
        const container = document.getElementById('cc-buttons-container');
        const reassignContainer = document.getElementById('reassign-buttons-container');
        const manualCCSelect = document.getElementById('manual-cc');
        
        CREDIT_CARD_OPTIONS.forEach(cardName => {
            // Initial Import Modal Buttons
            const btn1 = document.createElement('button');
            btn1.textContent = cardName;
            btn1.onclick = () => handleCreditCardSelection(cardName);
            container.appendChild(btn1);

            // Reassign CC Modal Buttons
            const btn2 = document.createElement('button');
            btn2.textContent = cardName;
            btn2.onclick = () => reassignCreditCard(reassigningFileIndex, cardName);
            reassignContainer.appendChild(btn2);
            
            // Manual Entry CC Dropdown Options
            const option = document.createElement('option');
            option.value = cardName;
            option.textContent = cardName;
            manualCCSelect.appendChild(option);
        });
        // Default the manual entry dropdown to the last option ('Manual') or first option
        manualCCSelect.value = 'Manual'; 
    })();
    
    // --- Utility Functions ---
    
    // Helper function to parse date strings and prevent timezone issues
    function parseDateInput(dateString) {
        // Appends T12:00:00 to treat the date as noon local time, mitigating timezone shifts
        if (!dateString) return null;
        // Check for common formats and handle them, but mostly rely on T12:00:00
        const datePart = dateString.split('T')[0];
        
        // This attempts to parse the date as a date string plus a time offset 
        // to prevent it from being interpreted as UTC midnight (which shifts the day).
        let date = new Date(datePart + 'T12:00:00');
        
        // Fallback for non-standard formats that the above logic might fail, but still need the local fix.
        // This is important for re-importing old, formatted dates.
        if (isNaN(date.getTime())) {
            date = new Date(dateString + 'T12:00:00');
        }

        // Final fallback on the raw string for very ambiguous formats
        if (isNaN(date.getTime())) {
            date = new Date(dateString);
        }
        
        return isNaN(date.getTime()) ? null : date;
    }
    
    function formatDate(dateString) {
        const date = parseDateInput(dateString); // Use parseDateInput to get a valid date
        if (date === null) return dateString; // Return original string if unparsable
        const options = { year: 'numeric', month: 'short', day: 'numeric' };
        return date.toLocaleDateString('en-US', options);
    }
    
    function formatCurrency(amount) {
        return new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: 'USD'
        }).format(amount);
    }
    
    function updateTotalsDisplay() {
        document.getElementById('full-original-total').textContent = formatCurrency(fullOriginalTotal);
        document.getElementById('full-my-total').textContent = formatCurrency(fullMyTotal);
    }
    
    function closeModal(id) {
        document.getElementById(id).style.display = 'none';
        if (id === 'customSplitModal') {
            currentTransactionIndex = null;
        } else if (id === 'manualTransactionModal') {
            editingTransactionIndex = null;
        }
    }
    
    function openModal(id) {
        document.getElementById(id).style.display = 'block';
    }

    window.onclick = function(event) {
        const customSplitModal = document.getElementById('customSplitModal');
        const ccSelectModal = document.getElementById('creditCardSelectModal');
        const changeCCModal = document.getElementById('changeCCModal');
        const manualTxnModal = document.getElementById('manualTransactionModal');
        const manageCatModal = document.getElementById('manageCategoryModal');
        const newCatModal = document.getElementById('newCategoryModal'); 
        
        if (event.target == customSplitModal) {
            closeModal('customSplitModal');
        } else if (event.target == ccSelectModal) {
            closeModal('creditCardSelectModal');
        } else if (event.target == changeCCModal) {
             closeModal('changeCCModal');
        } else if (event.target == manualTxnModal) {
             closeModal('manualTransactionModal');
        } else if (event.target == manageCatModal) {
             closeModal('manageCategoryModal');
        } else if (event.target == newCatModal) { 
             closeModal('newCategoryModal');
        }
    }

    // NEW FUNCTION: Calculates totals based on currently filtered/displayed transactions
    function calculateTotals() {
        fullOriginalTotal = 0;
        fullMyTotal = 0;

        // Define categories to exclude from the My Share total calculation (case-insensitive)
        const myShareExcludedCategories = new Set([
            "credit card payments",
            "transfers",
            "my payments"
        ]);
        
        // Define categories to exclude from the Full Total calculation
        // This is the V7 logic being reapplied to fix the grand total amount.
        const fullTotalExcludedCategories = new Set([
            "my payments" // Exclude 'my payments' from the Full Total sum
        ]);
        
        displayedTransactions.forEach(t => {
            // 1. Calculate Full Original Total (Excluding 'My Payments' which are positive credits/deposits)
            if (!fullTotalExcludedCategories.has(t.category.toLowerCase())) {
                fullOriginalTotal += t.originalAmount; 
            }

            // 2. Calculate My Share Total 
            // Only include in My Total if the category is NOT in the excluded list
            if (!myShareExcludedCategories.has(t.category.toLowerCase())) {
                fullMyTotal += t.myTotal;
            } else {
                // We do nothing if it's excluded, as handled by the IF above.
            }
        });
        
        updateTotalsDisplay();
    }
    
    // NEW FUNCTION - CORE FIX: Re-sorts displayedTransactions using the current global sort state.
    // Does NOT flip the direction, thus preserving the user's view.
    function reapplyCurrentSort() {
        const key = transactionSort.key;
        const direction = transactionSort.direction;
        
        displayedTransactions.sort((a, b) => {
            const aVal = a[key];
            const bVal = b[key];
            let comparison = 0;

            if (key === 'dateObj') {
                const aTime = aVal ? aVal.getTime() : 0;
                const bTime = bVal ? bVal.getTime() : 0;
                comparison = aTime - bTime;
            } else if (typeof aVal === 'number' && typeof bVal === 'number') {
                comparison = aVal - bVal;
            } else {
                // Handle null/undefined values gracefully
                const strA = String(aVal || '');
                const strB = String(bVal || '');
                comparison = strA.localeCompare(strB);
            }
            
            return direction === 'asc' ? comparison : -comparison;
        });
        
        updateSortIndicators('transactions-list', transactionSort);
        renderTransactions();
    }
    
    // --- End Utility Functions ---

    // --- Trigger File Input ---
    function triggerFileUpload(type) {
        currentImportType = type;
        document.getElementById('csv-file-input').click();
    }

    // --- Tab Switching ---
    function openTab(tabId, element) {
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
        document.querySelectorAll('.tab-button').forEach(button => button.classList.remove('active'));

        document.getElementById(tabId).classList.add('active');
        element.classList.add('active');
        
        if (tabId === 'imports-tab') {
            renderImportsHistory();
        } else if (tabId === 'category-breakdown-tab') {
            applyBreakdownFilter(); // Trigger calculation on tab switch
        }
    }

    // --- File Handling Functions ---
    function initializeFileUpload(event) {
        const fileList = event.target.files;
        if (fileList.length > 0) {
            filesToProcess.push(...Array.from(fileList));
            event.target.value = null; 
            processNextFileInQueue(); 
        }
    }

    function processNextFileInQueue() {
        if (filesToProcess.length > 0) {
            currentProcessingFile = filesToProcess.shift(); 
            
            if (currentImportType === 'old') {
                // SKIP CC MODAL for old data. Pass the skip constant.
                handleCreditCardSelection(SKIP_CC_SELECTION);
            } else {
                // Regular process: show modal for new data
                document.getElementById('cc-modal-title').textContent = `Select Card for: ${currentProcessingFile.name}`;
                openModal('creditCardSelectModal');
            }
        } else {
            processTransactions();
        }
    }
    
    function handleCreditCardSelection(selectedCard) {
        // Hide modal if it was open (including if the selection was a real click)
        document.getElementById('creditCardSelectModal').style.display = 'none';
        
        const file = currentProcessingFile;
        if (!file) {
            processNextFileInQueue();
            return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
            const csvData = e.target.result;
            // Pass the import type to parseCSV for logic branching
            const newTransactions = parseCSV(csvData, selectedCard, file.name, currentImportType); 
            
            transactions.push(...newTransactions); 
            
            if (newTransactions.length > 0) {
                // Use a unique ID based on timestamp for files
                const fileId = Date.now() + Math.random(); 
                
                importedFilesHistory.push({
                    id: fileId, 
                    fileName: file.name,
                    creditCard: selectedCard === SKIP_CC_SELECTION ? 'Multiple/Archived' : selectedCard, // Set placeholder for history
                    transactionCount: newTransactions.length
                });
            }

            currentProcessingFile = null; 
            processNextFileInQueue();
        };
        reader.readAsText(file);
    }

    function renderImportsHistory() {
        const tbody = document.getElementById('imports-body');
        tbody.innerHTML = '';

        // NEW: Filter out the MANUAL_ENTRY_ID
        const filteredHistory = importedFilesHistory.filter(f => f.id !== MANUAL_ENTRY_ID);

        if (filteredHistory.length === 0) {
            tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: #666; padding: 20px;">No files imported yet.</td></tr>';
            return;
        }

        filteredHistory.forEach((fileEntry, index) => {
            const row = tbody.insertRow();
            row.dataset.id = fileEntry.id;
            
            row.insertCell().textContent = fileEntry.fileName;
            row.insertCell().textContent = fileEntry.creditCard;
            row.insertCell().textContent = fileEntry.transactionCount;

            const actionCell = row.insertCell();
            actionCell.classList.add('actions');
            
            actionCell.innerHTML = `
                <div class="import-actions-grid">
                    <button class="btn-change-cc" onclick="openReassignModal(${fileEntry.id})">Change CC</button>
                    <button class="btn-delete" onclick="deleteImportedFile(${fileEntry.id})">Delete</button>
                </div>
            `;
            
        });
    }

    function openReassignModal(fileId) {
        if (fileId === MANUAL_ENTRY_ID) return; // Cannot reassign the manual entry group

        const fileEntry = importedFilesHistory.find(f => f.id === fileId);
        if (!fileEntry) return;

        reassigningFileIndex = fileId;
        document.getElementById('reassign-file-name').textContent = fileEntry.fileName;

        const oldContainer = document.getElementById('reassign-buttons-container');
        const newContainer = oldContainer.cloneNode(true);
        oldContainer.parentNode.replaceChild(newContainer, oldContainer);
        newContainer.id = 'reassign-buttons-container'; 

        const buttons = newContainer.querySelectorAll('button');
        buttons.forEach(button => {
            const cardName = button.textContent;
            button.onclick = () => reassignCreditCard(fileId, cardName);
        });

        openModal('changeCCModal');
    }

    function reassignCreditCard(fileId, newCard) {
        const fileEntry = importedFilesHistory.find(f => f.id === fileId);
        if (!fileEntry) return;

        transactions.forEach(t => {
            if (t.fileName === fileEntry.fileName) { 
                t.creditCard = newCard;
            }
        });

        fileEntry.creditCard = newCard;
        
        closeModal('changeCCModal');
        
        renderImportsHistory();
        applyDateFilter(); 
    }

    function deleteImportedFile(fileId) {
        if (fileId === MANUAL_ENTRY_ID) {
            // Manual entries are now deleted via the in-line button, but keep this check for safety.
            alert('Manual entries are managed via the Edit/Delete button in the transaction list.');
            return;
        } else {
            if (!confirm('Are you sure you want to delete this file and all its associated transactions? This action cannot be undone.')) return;

            const fileEntry = importedFilesHistory.find(f => f.id === fileId);
            if (!fileEntry) return;

            const fileNameToDelete = fileEntry.fileName;

            // Remove transactions associated with the file
            transactions = transactions.filter(t => t.fileName !== fileNameToDelete); 

            // Remove the file entry from history
            importedFilesHistory = importedFilesHistory.filter(f => f.id !== fileId);
        }
        
        // Recalculate unique categories after deletion
        uniqueCategories.clear();
        transactions.forEach(t => {
            if (t.category) uniqueCategories.add(t.category);
        });
        
        renderImportsHistory();
        applyDateFilter(); // Re-render transactions
        applyBreakdownFilter(); // Update breakdown
    }
    
    function parseCSV(csvData, creditCard, fileName, importType) {
        const lines = csvData.trim().split('\n');
        if (lines.length <= 1) {
            alert(`File "${fileName}" skipped: No data rows found.`);
            return [];
        }

        const EXCLUDED_CATEGORIES = ["credit card payments", "transfers"];

        const parseLine = (line) => {
            const result = [];
            let inQuotes = false;
            let currentField = '';
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(currentField.trim());
                    currentField = '';
                } else {
                    currentField += char;
                }
            }
            result.push(currentField.trim());
            return result.map(v => v.replace(/^"|"$/g, ''));
        };

        const header = parseLine(lines[0]);
        const dataLines = lines.slice(1);
        const parsedData = [];

        const headerMap = header.reduce((acc, col, index) => {
            const cleanCol = col.trim().toLowerCase();
            acc[cleanCol] = index;
            // Also map common variations of credit card column
            if (cleanCol.includes('credit card') || cleanCol.includes('cc') || cleanCol.includes('card name') || cleanCol.includes('account')) {
                acc['credit card from csv'] = index;
            }
            return acc;
        }, {});

        const dateIndex = headerMap['date'];
        const descIndex = headerMap['description'];
        const categoryIndex = headerMap['category'];
        // Check for 'amount' first, then fallback to 'original amount' for compatibility
        const amountIndex = headerMap['amount'] !== undefined ? headerMap['amount'] : headerMap['original amount'];
        const ccCsvIndex = headerMap['credit card from csv'];

        // INDICES FOR RE-IMPORTING OLD/EXPORTED DATA
        const myTotalIndex = headerMap['my total'];
        const statusIndex = headerMap['split status'];
        const notesIndex = headerMap['notes'];

        if (dateIndex === undefined || amountIndex === undefined) {
            alert(`File "${fileName}" skipped: CSV must contain 'Date' and one of 'Amount' or 'Original Amount' columns (case-insensitive).`);
            return [];
        }

        dataLines.forEach(line => {
            const values = parseLine(line);
            if (values.length > 0) {
                const amountStr = values[amountIndex] || '0';
                const originalAmount = parseFloat(amountStr.replace(/[^0-9.-]/g, '')) || 0;

                if (originalAmount === 0 && amountStr.replace(/[^0-9.-]/g, '').trim() !== '0') return;

                const category = (values[categoryIndex] || 'Uncategorized').trim(); // Trim category

                // Exclude "credit card payments" and "transfers"
                if (EXCLUDED_CATEGORIES.includes(category.toLowerCase())) {
                    return; // Skip this transaction
                }
                
                uniqueCategories.add(category);

                let finalCreditCard = creditCard;
                let myTotal = 0;
                let status = '';
                let notes = '';

                // LOGIC FOR "OLD DATA" IMPORT
                if (importType === 'old') {
                    // Try to auto-assign credit card from CSV
                    if (ccCsvIndex !== undefined) {
                        const csvCardValue = values[ccCsvIndex].trim();
                        finalCreditCard = csvCardValue || 'Archived Data';
                    } else {
                        // Fallback if no CC column found, use placeholder
                        finalCreditCard = 'Archived Data';
                    }

                    // Restore My Total, Status, and Notes if columns exist in the exported file
                    if (myTotalIndex !== undefined) {
                        const myTotalStr = values[myTotalIndex] || '0';
                        myTotal = parseFloat(myTotalStr.replace(/[^0-9.-]/g, '')) || 0;
                    }
                    if (statusIndex !== undefined) {
                        status = values[statusIndex].trim();
                    }
                    if (notesIndex !== undefined) {
                        notes = values[notesIndex].trim();
                    }

                } else if (finalCreditCard === SKIP_CC_SELECTION) {
                    // Fallback for 'old' data import that didn't have a CC column (left for safety, but above logic handles it)
                    finalCreditCard = 'Archived Data';
                }

                // Use parseDateInput to create dateObj
                const dateString = values[dateIndex];
                const dateObj = parseDateInput(dateString);

                parsedData.push({
                    date: dateString,
                    dateObj: dateObj,
                    description: values[descIndex] || '',
                    category: category,
                    creditCard: finalCreditCard,
                    originalAmount: originalAmount,
                    myTotal: myTotal, // Set to parsed value or default 0
                    status: status, // Set to parsed value or default ''
                    fileName: fileName,
                    notes: notes // Set to parsed value or default ''
                });
            }
        });

        if (parsedData.length === 0 && dataLines.length > 0) {
            console.warn(`Warning: Found data rows in "${fileName}" but parsed 0 transactions. Check CSV format.`);
        }
        
        return parsedData;
    }

    function processTransactions() {
        // Initial sort: Date ASC
        transactions.sort((a, b) => {
            if (!a.dateObj) return 1;
            if (!b.dateObj) return -1;
            return a.dateObj.getTime() - b.dateObj.getTime();
        });
        transactions.forEach(t => {
            if (t.category) uniqueCategories.add(t.category);
        });
        reRenderCategoryDropdowns();
        applyDateFilter();
    }
    
    // --- Transaction Sorting and Filtering --- 
    function sortTransactions(key) {
        if (transactionSort.key === key) {
            transactionSort.direction = transactionSort.direction === 'asc' ? 'desc' : 'asc';
        } else {
            transactionSort.key = key;
            // Default date sort to ASC (oldest first)
            transactionSort.direction = key === 'dateObj' ? 'asc' : 'desc'; 
        }

        reapplyCurrentSort(); // Use the dedicated reapply function to sort and render
    }

    function updateSortIndicators(listId, sortState) {
        document.querySelectorAll(`#${listId} th.sortable`).forEach(th => {
            th.classList.remove('asc', 'desc');
            if (th.dataset.sortKey === sortState.key) {
                th.classList.add(sortState.direction);
            }
        });
    }

    function applyDateFilter() {
        const preset = document.getElementById('date-range-preset').value;
        const customRangeDiv = document.getElementById('custom-date-range');
        let startDate = null;
        let endDate = null;

        if (preset === 'custom') {
            customRangeDiv.style.display = 'flex'; // Use flex now that it's a div containing labels/inputs
            startDate = document.getElementById('start-date').value ? parseDateInput(document.getElementById('start-date').value) : null;
            endDate = document.getElementById('end-date').value ? parseDateInput(document.getElementById('end-date').value) : null;
            if (endDate) endDate.setHours(23, 59, 59, 999);
        } else {
            customRangeDiv.style.display = 'none';
            const now = new Date();
            let year = now.getFullYear();
            let month = now.getMonth();

            if (preset === 'current_month') {
                startDate = new Date(year, month, 1);
                endDate = new Date(year, month + 1, 0);
                endDate.setHours(23, 59, 59, 999);
            } else if (preset === 'last_month') {
                startDate = new Date(year, month - 1, 1);
                endDate = new Date(year, month, 0);
                endDate.setHours(23, 59, 59, 999);
            }
            // All Time means null dates
        }

        displayedTransactions = transactions.filter(t => {
            const date = t.dateObj;
            // Critical check: only proceed if date is a valid object
            if (!date) return false;
            const meetsStart = !startDate || date >= startDate;
            const meetsEnd = !endDate || date <= endDate;
            return meetsStart && meetsEnd;
        });

        // FIX (part 1 of 2): Re-apply the current sort after filtering.
        reapplyCurrentSort(); 
        calculateTotals();
    }
    
    // --- Render Functions ---
    
    function getActionButtonsHTML(t, index) {
        const status = t.status || '';
        const isNA = status === 'N/A';
        const isFull = status === 'Full';
        const isHalf = status === 'Half';
        const isCustom = status.includes('Split') || status.includes('Custom');

        const naClass = isNA ? 'applied' : '';
        const fullClass = isFull ? 'applied' : '';
        const halfClass = isHalf ? 'applied' : '';
        const customClass = (isCustom && !isHalf) ? 'applied' : '';

        // FIX: Only show Edit / Delete button for Manual Entries
        let manualEditButtonHTML = '';
        if (t.fileName === 'Manual Entry') {
            manualEditButtonHTML = `
                <div class="action-buttons-grid single-button" style="margin-top: 5px;">
                     <button class="btn-full action-button" onclick="openEditTransactionModal(${index})" style="background-color: #CDE6F8 !important; border: 2px solid #76AFE5; color: #2473BC !important;">Edit / Delete</button>
                </div>
            `;
        }

        return `
            <div class="action-buttons-grid">
                <button class="btn-split-half action-button ${halfClass}" onclick="applySplitHalf(${index})">Half</button>
                <button class="btn-full action-button ${fullClass}" onclick="applySplitFull(${index})">Full</button>
                <button class="btn-split-custom action-button ${customClass}" onclick="openCustomSplitModal(${index})">Custom Split</button>
                <button class="btn-na action-button ${naClass}" onclick="applySplitNA(${index})">N/A</button>
            </div>
            ${manualEditButtonHTML}
        `;
    }

    function renderTransactions() {
        const tbody = document.getElementById('transactions-body');
        tbody.innerHTML = '';
        
        if (displayedTransactions.length === 0) {
            tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; color: #666; padding: 20px;">No transactions match the current filter.</td></tr>';
            updateTotalsDisplay(); 
            return;
        }

        displayedTransactions.forEach((t, index) => {
            const row = tbody.insertRow();
            row.classList.toggle('na-applied', t.status === 'N/A');
            
            row.insertCell().textContent = formatDate(t.date); 
            row.insertCell().textContent = t.creditCard;
            row.insertCell().textContent = t.description;
            
            // Category Select
            const categoryCell = row.insertCell();
            categoryCell.innerHTML = `
                <select class="category-select" onchange="updateTransactionCategory(${index}, this.value)">
                    ${Array.from(uniqueCategories).sort().map(cat => 
                        `<option value="${cat}" ${t.category === cat ? 'selected' : ''}>${cat}</option>`
                    ).join('')}
                </select>
            `;

            row.insertCell().innerHTML = `<span class="${t.originalAmount <= 0 ? 'negative' : 'positive'}">${formatCurrency(t.originalAmount)}</span>`;
            row.insertCell().innerHTML = `<span class="${t.myTotal <= 0 ? 'negative' : 'positive'}">${formatCurrency(t.myTotal)}</span>`;

            // Action Buttons
            row.insertCell().innerHTML = getActionButtonsHTML(t, index);

            // Notes Input
            const notesCell = row.insertCell();
            notesCell.innerHTML = `<input type="text" class="notes-input" value="${t.notes || ''}" onchange="updateTransactionNotes(${index}, this.value)">`;
        });
        
        updateTotalsDisplay();
    }
    
    // --- Transaction Action Handlers ---
    
    // Central function to apply the split status change
    function applyAction(action, index, customValue = null, ways = 2) {
        const t = displayedTransactions[index];
        if (!t) return;

        // Apply the logic
        switch (action) {
            case 'half':
                t.status = 'Half';
                t.myTotal = parseFloat((t.originalAmount / 2).toFixed(2));
                break;
            case 'full':
                t.status = 'Full';
                t.myTotal = t.originalAmount;
                break;
            case 'na':
                t.status = 'N/A';
                t.myTotal = 0;
                break;
            case 'custom-split': // This is the old custom split logic, now handled by the new modal
            case 'custom-portion': // This is the old custom split logic, now handled by the new modal
                t.status = 'Custom Split'; // The new custom split function will overwrite myTotal
                t.myTotal = parseFloat(customValue);
                break;
        }

        // FIX (part 2 of 2): Recalculate totals and re-render using the existing sort state.
        calculateTotals();
        reapplyCurrentSort();
    }

    function applySplitHalf(index) {
        applyAction('half', index);
    }

    function applySplitFull(index) {
        applyAction('full', index);
    }

    function applySplitNA(index) {
        applyAction('na', index);
    }
    
    function updateTransactionNotes(index, value) {
        const t = displayedTransactions[index];
        if (t) {
            t.notes = value;
            // No need to re-render the whole table, but we do need to update it in the original array
            // Since the object is passed by reference, it is already updated in the main 'transactions' array.
        }
    }
    
    function updateTransactionCategory(index, newCategory) {
        const t = displayedTransactions[index];
        if (t) {
            t.category = newCategory;
            // No full re-render/re-sort needed, but we do need to recalculate totals
            calculateTotals(); 
            // Re-render only to update the category in the dropdowns (optional, but good practice)
            // Or just trust the current element is updated and re-render the breakdown tab only
            applyBreakdownFilter();
        }
    }

    // --- Custom Split Modal Handlers (UPDATED) ---
    
    function openCustomSplitModal(index) {
        currentTransactionIndex = index; // Store the index globally
        const t = displayedTransactions[index];
        if (!t) return;

        document.getElementById('modal-date').textContent = formatDate(t.date);
        document.getElementById('modal-description').textContent = t.description;
        document.getElementById('modal-category').textContent = t.category;
        document.getElementById('modal-original-amount').textContent = formatCurrency(t.originalAmount);
        
        // Reset inputs
        document.getElementById('custom-amount-input').value = '';
        document.querySelector('input[name="custom-type"][value="transaction"]').checked = true;

        openModal('customSplitModal');
    }
    
    function applyCustomSplit() {
        const amountInput = document.getElementById('custom-amount-input');
        const customAmountRaw = parseFloat(amountInput.value);
        const typeSelection = document.querySelector('input[name="custom-type"]:checked').value;

        if (isNaN(customAmountRaw) || customAmountRaw <= 0) {
            alert('Please enter a valid positive amount.');
            return;
        }
        
        // The amount entered is always positive. We apply the sign based on type.
        let myTotal;
        
        if (typeSelection === 'transaction') {
            // Transaction/Expense: My Total should be negative
            myTotal = -Math.abs(customAmountRaw);
        } else {
            // Refund/Credit: My Total should be positive
            myTotal = Math.abs(customAmountRaw);
        }
        
        // Apply the split
        const t = displayedTransactions[currentTransactionIndex];
        if (t) {
            t.status = 'Custom Split';
            t.myTotal = parseFloat(myTotal.toFixed(2));
        }
        
        closeModal('customSplitModal');

        // Recalculate and re-render with preserved sort state.
        calculateTotals();
        reapplyCurrentSort(); 
    }
    
    // --- Manual Transaction Handlers (Essential to complete the flow) ---
    function openManualTransactionModal(index = null) {
        const modal = document.getElementById('manualTransactionModal');
        const saveBtn = document.getElementById('manual-save-btn');
        const isEditing = index !== null;
        editingTransactionIndex = index;
        
        // Reset form
        modal.dataset.context = isEditing ? 'edit' : 'add';
        document.querySelector('#manualTransactionModal h2').textContent = isEditing ? 'Edit Transaction' : 'Add Manual Transaction';
        saveBtn.textContent = isEditing ? 'Save Changes' : 'Save Transaction';
        
        // Clear all inputs
        document.getElementById('manual-date').value = '';
        document.getElementById('manual-cc').value = 'Manual';
        document.getElementById('manual-desc').value = '';
        document.getElementById('manual-original-amount').value = '';
        document.getElementById('manual-my-total').value = '';
        document.getElementById('manual-notes').value = '';

        // Reset split buttons
        document.querySelectorAll('#manual-split-buttons .action-button').forEach(btn => btn.classList.remove('applied'));
        document.getElementById('manual-my-total').disabled = false;

        reRenderCategoryDropdowns('manual-category');

        if (isEditing) {
            const t = displayedTransactions[index];
            if (!t) return;
            
            // Format date for input[type="date"] (YYYY-MM-DD)
            const dateParts = t.date.split('/'); // Assumes MM/DD/YYYY format from CSV
            const formattedDate = t.dateObj ? t.dateObj.toISOString().split('T')[0] : '';
            
            document.getElementById('manual-date').value = formattedDate;
            document.getElementById('manual-cc').value = t.creditCard;
            document.getElementById('manual-desc').value = t.description;
            document.getElementById('manual-category').value = t.category;
            document.getElementById('manual-original-amount').value = t.originalAmount;
            document.getElementById('manual-my-total').value = t.myTotal;
            document.getElementById('manual-notes').value = t.notes;
            
            // Set split button status
            document.querySelectorAll('#manual-split-buttons .action-button').forEach(btn => {
                if (btn.dataset.action === t.status.toLowerCase().replace(' ', '-').split(' ')[0]) {
                    btn.classList.add('applied');
                    if (btn.dataset.action !== 'custom') {
                         document.getElementById('manual-my-total').disabled = true;
                    }
                }
            });
            
            // Add Delete button only in edit mode
            const actionButtons = document.getElementById('manual-modal-action-buttons');
            let deleteBtn = document.getElementById('manual-delete-btn');
            if (!deleteBtn) {
                deleteBtn = document.createElement('button');
                deleteBtn.id = 'manual-delete-btn';
                deleteBtn.textContent = 'Delete Transaction';
                deleteBtn.className = 'btn-delete';
                deleteBtn.onclick = () => { deleteTransaction(index); closeModal('manualTransactionModal'); };
                actionButtons.insertBefore(deleteBtn, saveBtn);
            }
        } else {
            // Remove delete button if it exists and we're in add mode
            const deleteBtn = document.getElementById('manual-delete-btn');
            if (deleteBtn) deleteBtn.remove();
        }

        openModal('manualTransactionModal');
    }

    function handleManualAmountChange() {
        const originalAmountInput = document.getElementById('manual-original-amount');
        const myTotalInput = document.getElementById('manual-my-total');
        const splitButtons = document.querySelectorAll('#manual-split-buttons .action-button.applied');
        
        const originalAmount = parseFloat(originalAmountInput.value) || 0;
        
        if (splitButtons.length === 1) {
            const action = splitButtons[0].dataset.action;
            let newMyTotal = 0;
            if (action === 'full') {
                newMyTotal = originalAmount;
            } else if (action === 'half') {
                newMyTotal = originalAmount / 2;
            } else if (action === 'na') {
                newMyTotal = 0;
            }
            myTotalInput.value = newMyTotal.toFixed(2);
        }
    }

    function handleManualSplitAction(action) {
        document.querySelectorAll('#manual-split-buttons .action-button').forEach(btn => btn.classList.remove('applied'));
        const targetButton = document.querySelector(`#manual-split-buttons button[data-action="${action}"]`);
        if (targetButton) {
            targetButton.classList.add('applied');
        }

        const myTotalInput = document.getElementById('manual-my-total');
        myTotalInput.disabled = (action !== 'custom');

        handleManualAmountChange(); // Recalculate myTotal based on new action
    }

    function openManualCustomSplitModal() {
        // This is a placeholder as the simple manual modal doesn't support the full custom split options
        handleManualSplitAction('custom');
    }
    
    function handleManualMyTotalInput() {
        // If user manually edits myTotal, force the status to 'custom'
        handleManualSplitAction('custom');
    }
    
    function saveManualTransaction() {
        const dateInput = document.getElementById('manual-date');
        const ccInput = document.getElementById('manual-cc');
        const descInput = document.getElementById('manual-desc');
        const categoryInput = document.getElementById('manual-category');
        const originalAmountInput = document.getElementById('manual-original-amount');
        const myTotalInput = document.getElementById('manual-my-total');
        const notesInput = document.getElementById('manual-notes');
        
        if (!dateInput.value || !originalAmountInput.value) {
            alert('Date and Original Amount are required.');
            return;
        }

        const originalAmount = parseFloat(originalAmountInput.value);
        const myTotal = parseFloat(myTotalInput.value);
        const dateObj = parseDateInput(dateInput.value);

        const selectedAction = document.querySelector('#manual-split-buttons .action-button.applied');
        let status = selectedAction ? selectedAction.dataset.action : '';
        if (status === 'half') status = 'Half';
        else if (status === 'full') status = 'Full';
        else if (status === 'na') status = 'N/A';
        else if (status === 'custom') status = 'Custom Split';
        
        const newTransaction = {
            date: dateInput.value,
            dateObj: dateObj,
            creditCard: ccInput.value,
            description: descInput.value || 'Manual Entry',
            category: categoryInput.value || 'Uncategorized',
            originalAmount: originalAmount,
            myTotal: myTotal,
            status: status,
            fileName: 'Manual Entry',
            notes: notesInput.value || ''
        };
        
        uniqueCategories.add(newTransaction.category);

        if (editingTransactionIndex !== null) {
            // Edit existing transaction (update both in full list and displayed list)
            const oldT = displayedTransactions[editingTransactionIndex];
            // Find the original index in the full 'transactions' array to ensure persistence
            const originalIndex = transactions.findIndex(t => t.date === oldT.date && t.description === oldT.description && t.originalAmount === oldT.originalAmount);
            
            Object.assign(oldT, newTransaction); // Update displayed
            if (originalIndex !== -1) {
                Object.assign(transactions[originalIndex], newTransaction); // Update full list
            }
        } else {
            // Add new transaction
            transactions.push(newTransaction);
        }
        
        closeModal('manualTransactionModal');
        
        // FIX: Recalculate totals and re-render with preserved sort state.
        reRenderCategoryDropdowns();
        applyDateFilter(); // This will re-filter, re-sort, and re-render
    }

    function deleteTransaction(index) {
        if (!confirm('Are you sure you want to delete this transaction? This action cannot be undone.')) return;
        
        const t = displayedTransactions[index];
        if (!t) return;
        
        // Remove from the full list
        transactions = transactions.filter(item => item !== t);
        
        // The display list will be filtered/sorted/rendered next, but we remove the item 
        // from the displayed list right away to prevent issues if it's the only one.
        displayedTransactions.splice(index, 1);
        
        // Recalculate totals and re-render with preserved sort state.
        calculateTotals();
        reapplyCurrentSort(); 
        
        closeModal('manualTransactionModal');
        applyBreakdownFilter();
    }
    
    // --- Category Management Handlers (Essential to complete the flow) ---

    function reRenderCategoryDropdowns(targetId = null) {
        const categoryList = Array.from(uniqueCategories).sort();
        
        const renderOptions = (selectedValue) => {
            return categoryList.map(cat => 
                `<option value="${cat}" ${selectedValue === cat ? 'selected' : ''}>${cat}</option>`
            ).join('');
        };
        
        // Update Manual Entry Modal dropdown
        if (targetId === 'manual-category') {
            const select = document.getElementById('manual-category');
            if (select) {
                const selectedValue = select.value;
                select.innerHTML = renderOptions(selectedValue);
            }
            return;
        }

        // Re-render all category selects in the table
        document.querySelectorAll('.category-select').forEach(select => {
            const selectedValue = select.value;
            select.innerHTML = renderOptions(selectedValue);
        });
    }

    function openNewCategoryModal() {
        document.getElementById('new-category-name-input').value = '';
        openModal('newCategoryModal');
    }

    function addNewCategory() {
        const newCatName = document.getElementById('new-category-name-input').value.trim();
        if (newCatName && !uniqueCategories.has(newCatName)) {
            uniqueCategories.add(newCatName);
            reRenderCategoryDropdowns();
            applyBreakdownFilter();
            closeModal('newCategoryModal');
        } else if (uniqueCategories.has(newCatName)) {
            alert('Category already exists.');
        } else {
            alert('Please enter a category name.');
        }
    }
    
    function openManageCategoryModal(category) {
        currentManagingCategory = category;
        document.getElementById('current-category-name-display').textContent = category;
        document.getElementById('new-category-name').value = category;
        openModal('manageCategoryModal');
    }
    
    function performRenameCategory() {
        const oldCat = currentManagingCategory;
        const newCat = document.getElementById('new-category-name').value.trim();
        
        if (!newCat || newCat === oldCat) {
            alert('Invalid or unchanged category name.');
            return;
        }
        
        if (uniqueCategories.has(newCat)) {
            alert(`Category "${newCat}" already exists. Cannot rename.`);
            return;
        }
        
        // 1. Update transactions
        transactions.forEach(t => {
            if (t.category === oldCat) {
                t.category = newCat;
            }
        });
        
        // 2. Update set
        uniqueCategories.delete(oldCat);
        uniqueCategories.add(newCat);
        
        // 3. Refresh UI
        reRenderCategoryDropdowns();
        applyBreakdownFilter(); // Recalculates and re-renders breakdown list
        renderTransactions(); // Re-renders transaction list with new dropdowns
        closeModal('manageCategoryModal');
    }
    
    function deleteCategory(categoryToDelete) {
        if (!confirm(`WARNING: Deleting category "${categoryToDelete}" will re-categorize all associated transactions to 'Uncategorized'. Are you sure?`)) return;

        // 1. Update transactions to 'Uncategorized'
        transactions.forEach(t => {
            if (t.category === categoryToDelete) {
                t.category = 'Uncategorized';
            }
        });

        // Ensure 'Uncategorized' exists after deletion
        uniqueCategories.add('Uncategorized');

        // 2. Remove from set
        uniqueCategories.delete(categoryToDelete);
        
        // 3. Refresh UI
        reRenderCategoryDropdowns();
        applyBreakdownFilter(); 
        renderTransactions();
        closeModal('manageCategoryModal');
    }

    // --- Category Breakdown Functions ---

    function applyBreakdownFilter() {
        const preset = document.getElementById('breakdown-date-range-preset').value;
        let startDate = null;
        let endDate = null;
        const now = new Date();
        let year = now.getFullYear();
        let month = now.getMonth();

        if (preset === 'current_month') {
            startDate = new Date(year, month, 1);
            endDate = new Date(year, month + 1, 0);
            endDate.setHours(23, 59, 59, 999);
        } else if (preset === 'last_month') {
            startDate = new Date(year, month - 1, 1);
            endDate = new Date(year, month, 0);
            endDate.setHours(23, 59, 59, 999);
        }

        const filteredTxns = transactions.filter(t => {
            const date = t.dateObj;
            if (!date) return false;
            const meetsStart = !startDate || date >= startDate;
            const meetsEnd = !endDate || date <= endDate;
            return meetsStart && meetsEnd;
        });

        const breakdown = {};
        let totalOriginalAmount = 0;
        let totalMyShare = 0;

        filteredTxns.forEach(t => {
            const cat = t.category || 'Uncategorized';
            if (!breakdown[cat]) {
                breakdown[cat] = {
                    category: cat,
                    count: 0,
                    originalAmount: 0,
                    myTotal: 0
                };
            }
            breakdown[cat].count++;
            breakdown[cat].originalAmount += t.originalAmount;
            breakdown[cat].myTotal += t.myTotal;

            totalOriginalAmount += t.originalAmount;
            totalMyShare += t.myTotal;
        });

        // Convert to array and calculate percentages
        currentBreakdownData = Object.values(breakdown).map(item => ({
            ...item,
            percentage: totalOriginalAmount !== 0 ? (item.originalAmount / totalOriginalAmount) * 100 : 0
        }));

        // Now sort the data before rendering
        sortBreakdown(breakdownSort.key);
        renderBreakdown(currentBreakdownData.reduce((sum, item) => sum + item.originalAmount, 0), currentBreakdownData.reduce((sum, item) => sum + item.myTotal, 0));
    }
    
    function sortBreakdown(key) {
        if (breakdownSort.key === key) {
            breakdownSort.direction = breakdownSort.direction === 'asc' ? 'desc' : 'asc';
        } else {
            breakdownSort.key = key;
            breakdownSort.direction = key === 'category' ? 'asc' : 'desc'; 
        }

        currentBreakdownData.sort((a, b) => {
            const aVal = a[key];
            const bVal = b[key];
            let comparison = 0;

            if (typeof aVal === 'number' && typeof bVal === 'number') {
                comparison = aVal - bVal;
            } else {
                comparison = String(aVal).localeCompare(String(bVal));
            }
            
            return breakdownSort.direction === 'asc' ? comparison : -comparison;
        });
        
        updateSortIndicators('category-breakdown-list', breakdownSort);
        renderBreakdown(currentBreakdownData.reduce((sum, item) => sum + item.originalAmount, 0), currentBreakdownData.reduce((sum, item) => sum + item.myTotal, 0));
    }
    
    function renderBreakdown(totalOriginalAmount, totalMyShare) {
        const tbody = document.getElementById('breakdown-body');
        const tfoot = document.getElementById('breakdown-footer');
        tbody.innerHTML = '';
        tfoot.innerHTML = '';

        if (currentBreakdownData.length === 0) {
            tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: #666; padding: 20px;">No transactions found for the selected range.</td></tr>';
            return;
        }

        currentBreakdownData.forEach(item => {
            const row = tbody.insertRow();
            
            row.insertCell().textContent = item.category;
            row.insertCell().textContent = item.count;
            row.insertCell().textContent = `${item.percentage.toFixed(2)}%`;
            row.insertCell().textContent = formatCurrency(item.originalAmount);
            row.insertCell().textContent = formatCurrency(item.myTotal);

            const actionCell = row.insertCell();
            actionCell.innerHTML = `
                <button class="btn-full action-button" onclick="openManageCategoryModal('${item.category}')" style="padding: 6px 5px; font-size: 0.8rem;">Manage</button>
            `;
        });
        
        // Render Footer Totals
        const footerRow = tfoot.insertRow();
        footerRow.innerHTML = `
            <td colspan="3" style="text-align: right; font-weight: bold; background-color: #f8fbfe;">GRAND TOTAL:</td>
            <td style="font-weight: bold; background-color: #f8fbfe;">${formatCurrency(totalOriginalAmount)}</td>
            <td style="font-weight: bold; background-color: #f8fbfe;">${formatCurrency(totalMyShare)}</td>
            <td style="background-color: #f8fbfe;"></td>
        `;
    }

    // --- Export Function ---
    function exportToCSV() {
        const clean = (str) => {
            if (str === null || str === undefined) return '';
            // Escape double quotes by doubling them, then wrap in double quotes
            return `"${String(str).replace(/"/g, '""')}"`; 
        };

        const today = new Date();
        const todayStr = `${today.getFullYear()}-${(today.getMonth() + 1).toString().padStart(2, '0')}-${today.getDate().toString().padStart(2, '0')}`;

        const csvRows = [];
        const headers = [
            'Date', 'Credit Card', 'Description', 'Category', 'Original Amount', 
            'My Total', 'Split Status', 'File Name', 'Notes'
        ];
        csvRows.push(headers.map(h => clean(h)).join(','));

        // Use the full transaction list for export, not the filtered one
        transactions.forEach(t => {
            const row = [
                clean(t.date),
                clean(t.creditCard),
                clean(t.description),
                clean(t.category),
                t.originalAmount.toFixed(2), 
                t.myTotal.toFixed(2),
                clean(t.status),
                clean(t.fileName),
                clean(t.notes)
            ];
            csvRows.push(row.join(','));
        });

        const csvString = csvRows.join('\n');
        const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");

        if (link.download !== undefined) { 
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            // MODIFIED: Use the local date string
            link.setAttribute("download", "transaction_export_" + todayStr + ".csv"); 
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } else {
            alert("Your browser does not support downloading files directly. Please copy the data manually.");
        }
    }
    
    // Initial call to set filters and render if data exists (for persistence)
    document.addEventListener('DOMContentLoaded', () => {
         applyDateFilter(); 
         applyBreakdownFilter(); 
    });
</script>

</body>
</html>
